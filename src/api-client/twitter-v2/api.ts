/* tslint:disable */
/* eslint-disable */
/**
 * Twitter API v2
 * Twitter API v2 available endpoints
 *
 * The version of the OpenAPI document: 2.62
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * @type AddOrDeleteRulesRequest
 * @export
 */
export type AddOrDeleteRulesRequest = AddRulesRequest | DeleteRulesRequest;

/**
 * A response from modifying user-specified stream filtering rules.
 * @export
 * @interface AddOrDeleteRulesResponse
 */
export interface AddOrDeleteRulesResponse {
    /**
     * All user-specified stream filtering rules that were created.
     * @type {Array<Rule>}
     * @memberof AddOrDeleteRulesResponse
     */
    'data'?: Array<Rule>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof AddOrDeleteRulesResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {RulesResponseMetadata}
     * @memberof AddOrDeleteRulesResponse
     */
    'meta': RulesResponseMetadata;
}
/**
 * A request to add a user-specified stream filtering rule.
 * @export
 * @interface AddRulesRequest
 */
export interface AddRulesRequest {
    /**
     * 
     * @type {Array<RuleNoId>}
     * @memberof AddRulesRequest
     */
    'add': Array<RuleNoId>;
}
/**
 * 
 * @export
 * @interface AnimatedGif
 */
export interface AnimatedGif extends Media {
    /**
     * 
     * @type {string}
     * @memberof AnimatedGif
     */
    'preview_image_url'?: string;
    /**
     * An array of all available variants of the media.
     * @type {Array<Variant>}
     * @memberof AnimatedGif
     */
    'variants'?: Array<Variant>;
}
/**
 * 
 * @export
 * @interface AnimatedGifAllOf
 */
export interface AnimatedGifAllOf {
    /**
     * 
     * @type {string}
     * @memberof AnimatedGifAllOf
     */
    'preview_image_url'?: string;
    /**
     * An array of all available variants of the media.
     * @type {Array<Variant>}
     * @memberof AnimatedGifAllOf
     */
    'variants'?: Array<Variant>;
}
/**
 * 
 * @export
 * @interface BlockUserMutationResponse
 */
export interface BlockUserMutationResponse {
    /**
     * 
     * @type {BlockUserMutationResponseData}
     * @memberof BlockUserMutationResponse
     */
    'data'?: BlockUserMutationResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof BlockUserMutationResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface BlockUserMutationResponseData
 */
export interface BlockUserMutationResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof BlockUserMutationResponseData
     */
    'blocking'?: boolean;
}
/**
 * 
 * @export
 * @interface BlockUserRequest
 */
export interface BlockUserRequest {
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof BlockUserRequest
     */
    'target_user_id': string;
}
/**
 * 
 * @export
 * @interface BookmarkAddRequest
 */
export interface BookmarkAddRequest {
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof BookmarkAddRequest
     */
    'tweet_id': string;
}
/**
 * 
 * @export
 * @interface BookmarkMutationResponse
 */
export interface BookmarkMutationResponse {
    /**
     * 
     * @type {BookmarkMutationResponseData}
     * @memberof BookmarkMutationResponse
     */
    'data'?: BookmarkMutationResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof BookmarkMutationResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface BookmarkMutationResponseData
 */
export interface BookmarkMutationResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof BookmarkMutationResponseData
     */
    'bookmarked'?: boolean;
}
/**
 * 
 * @export
 * @interface CashtagEntity
 */
export interface CashtagEntity {
    /**
     * Index (zero-based) at which position this entity ends.  The index is exclusive.
     * @type {number}
     * @memberof CashtagEntity
     */
    'end': number;
    /**
     * Index (zero-based) at which position this entity starts.  The index is inclusive.
     * @type {number}
     * @memberof CashtagEntity
     */
    'start': number;
    /**
     * 
     * @type {string}
     * @memberof CashtagEntity
     */
    'tag': string;
}
/**
 * Represent the portion of text recognized as a Cashtag, and its start and end position within the text.
 * @export
 * @interface CashtagFields
 */
export interface CashtagFields {
    /**
     * 
     * @type {string}
     * @memberof CashtagFields
     */
    'tag': string;
}
/**
 * Your client has gone away.
 * @export
 * @interface ClientDisconnectedProblem
 */
export interface ClientDisconnectedProblem extends Problem {
}
/**
 * A problem that indicates your client is forbidden from making this request.
 * @export
 * @interface ClientForbiddenProblem
 */
export interface ClientForbiddenProblem extends Problem {
    /**
     * 
     * @type {string}
     * @memberof ClientForbiddenProblem
     */
    'reason'?: ClientForbiddenProblemReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof ClientForbiddenProblem
     */
    'registration_url'?: string;
}

export const ClientForbiddenProblemReasonEnum = {
    OfficialClientForbidden: 'official-client-forbidden',
    ClientNotEnrolled: 'client-not-enrolled'
} as const;

export type ClientForbiddenProblemReasonEnum = typeof ClientForbiddenProblemReasonEnum[keyof typeof ClientForbiddenProblemReasonEnum];

/**
 * 
 * @export
 * @interface ClientForbiddenProblemAllOf
 */
export interface ClientForbiddenProblemAllOf {
    /**
     * 
     * @type {string}
     * @memberof ClientForbiddenProblemAllOf
     */
    'reason'?: ClientForbiddenProblemAllOfReasonEnum;
    /**
     * 
     * @type {string}
     * @memberof ClientForbiddenProblemAllOf
     */
    'registration_url'?: string;
}

export const ClientForbiddenProblemAllOfReasonEnum = {
    OfficialClientForbidden: 'official-client-forbidden',
    ClientNotEnrolled: 'client-not-enrolled'
} as const;

export type ClientForbiddenProblemAllOfReasonEnum = typeof ClientForbiddenProblemAllOfReasonEnum[keyof typeof ClientForbiddenProblemAllOfReasonEnum];

/**
 * 
 * @export
 * @interface ComplianceJob
 */
export interface ComplianceJob {
    /**
     * Creation time of the compliance job.
     * @type {string}
     * @memberof ComplianceJob
     */
    'created_at': string;
    /**
     * Expiration time of the download URL.
     * @type {string}
     * @memberof ComplianceJob
     */
    'download_expires_at': string;
    /**
     * URL from which the user will retrieve their compliance results.
     * @type {string}
     * @memberof ComplianceJob
     */
    'download_url': string;
    /**
     * Compliance Job ID.
     * @type {string}
     * @memberof ComplianceJob
     */
    'id': string;
    /**
     * User-provided name for a compliance job.
     * @type {string}
     * @memberof ComplianceJob
     */
    'name'?: string;
    /**
     * 
     * @type {ComplianceJobStatus}
     * @memberof ComplianceJob
     */
    'status': ComplianceJobStatus;
    /**
     * 
     * @type {ComplianceJobType}
     * @memberof ComplianceJob
     */
    'type': ComplianceJobType;
    /**
     * Expiration time of the upload URL.
     * @type {string}
     * @memberof ComplianceJob
     */
    'upload_expires_at': string;
    /**
     * URL to which the user will upload their Tweet or user IDs.
     * @type {string}
     * @memberof ComplianceJob
     */
    'upload_url': string;
}


/**
 * Status of a compliance job.
 * @export
 * @enum {string}
 */

export const ComplianceJobStatus = {
    Created: 'created',
    InProgress: 'in_progress',
    Failed: 'failed',
    Complete: 'complete',
    Expired: 'expired'
} as const;

export type ComplianceJobStatus = typeof ComplianceJobStatus[keyof typeof ComplianceJobStatus];


/**
 * Type of compliance job to list.
 * @export
 * @enum {string}
 */

export const ComplianceJobType = {
    Tweets: 'tweets',
    Users: 'users'
} as const;

export type ComplianceJobType = typeof ComplianceJobType[keyof typeof ComplianceJobType];


/**
 * You cannot create a new job if one is already in progress.
 * @export
 * @interface ConflictProblem
 */
export interface ConflictProblem extends Problem {
}
/**
 * A problem that indicates something is wrong with the connection.
 * @export
 * @interface ConnectionExceptionProblem
 */
export interface ConnectionExceptionProblem extends Problem {
    /**
     * 
     * @type {string}
     * @memberof ConnectionExceptionProblem
     */
    'connection_issue'?: ConnectionExceptionProblemConnectionIssueEnum;
}

export const ConnectionExceptionProblemConnectionIssueEnum = {
    TooManyConnections: 'TooManyConnections',
    ProvisioningSubscription: 'ProvisioningSubscription',
    RuleConfigurationIssue: 'RuleConfigurationIssue',
    RulesInvalidIssue: 'RulesInvalidIssue'
} as const;

export type ConnectionExceptionProblemConnectionIssueEnum = typeof ConnectionExceptionProblemConnectionIssueEnum[keyof typeof ConnectionExceptionProblemConnectionIssueEnum];

/**
 * 
 * @export
 * @interface ConnectionExceptionProblemAllOf
 */
export interface ConnectionExceptionProblemAllOf {
    /**
     * 
     * @type {string}
     * @memberof ConnectionExceptionProblemAllOf
     */
    'connection_issue'?: ConnectionExceptionProblemAllOfConnectionIssueEnum;
}

export const ConnectionExceptionProblemAllOfConnectionIssueEnum = {
    TooManyConnections: 'TooManyConnections',
    ProvisioningSubscription: 'ProvisioningSubscription',
    RuleConfigurationIssue: 'RuleConfigurationIssue',
    RulesInvalidIssue: 'RulesInvalidIssue'
} as const;

export type ConnectionExceptionProblemAllOfConnectionIssueEnum = typeof ConnectionExceptionProblemAllOfConnectionIssueEnum[keyof typeof ConnectionExceptionProblemAllOfConnectionIssueEnum];

/**
 * Annotation inferred from the Tweet text.
 * @export
 * @interface ContextAnnotation
 */
export interface ContextAnnotation {
    /**
     * 
     * @type {ContextAnnotationDomainFields}
     * @memberof ContextAnnotation
     */
    'domain': ContextAnnotationDomainFields;
    /**
     * 
     * @type {ContextAnnotationEntityFields}
     * @memberof ContextAnnotation
     */
    'entity': ContextAnnotationEntityFields;
}
/**
 * Represents the data for the context annotation domain.
 * @export
 * @interface ContextAnnotationDomainFields
 */
export interface ContextAnnotationDomainFields {
    /**
     * Description of the context annotation domain.
     * @type {string}
     * @memberof ContextAnnotationDomainFields
     */
    'description'?: string;
    /**
     * The unique id for a context annotation domain.
     * @type {string}
     * @memberof ContextAnnotationDomainFields
     */
    'id': string;
    /**
     * Name of the context annotation domain.
     * @type {string}
     * @memberof ContextAnnotationDomainFields
     */
    'name'?: string;
}
/**
 * Represents the data for the context annotation entity.
 * @export
 * @interface ContextAnnotationEntityFields
 */
export interface ContextAnnotationEntityFields {
    /**
     * Description of the context annotation entity.
     * @type {string}
     * @memberof ContextAnnotationEntityFields
     */
    'description'?: string;
    /**
     * The unique id for a context annotation entity.
     * @type {string}
     * @memberof ContextAnnotationEntityFields
     */
    'id': string;
    /**
     * Name of the context annotation entity.
     * @type {string}
     * @memberof ContextAnnotationEntityFields
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CreateAttachmentsMessageRequest
 */
export interface CreateAttachmentsMessageRequest {
    /**
     * Attachments to a DM Event.
     * @type {Array<DmMediaAttachment>}
     * @memberof CreateAttachmentsMessageRequest
     */
    'attachments': Array<DmMediaAttachment>;
    /**
     * Text of the message.
     * @type {string}
     * @memberof CreateAttachmentsMessageRequest
     */
    'text'?: string;
}
/**
 * A request to create a new batch compliance job.
 * @export
 * @interface CreateComplianceJobRequest
 */
export interface CreateComplianceJobRequest {
    /**
     * User-provided name for a compliance job.
     * @type {string}
     * @memberof CreateComplianceJobRequest
     */
    'name'?: string;
    /**
     * If true, this endpoint will return a pre-signed URL with resumable uploads enabled.
     * @type {boolean}
     * @memberof CreateComplianceJobRequest
     */
    'resumable'?: boolean;
    /**
     * Type of compliance job to list.
     * @type {string}
     * @memberof CreateComplianceJobRequest
     */
    'type': CreateComplianceJobRequestTypeEnum;
}

export const CreateComplianceJobRequestTypeEnum = {
    Tweets: 'tweets',
    Users: 'users'
} as const;

export type CreateComplianceJobRequestTypeEnum = typeof CreateComplianceJobRequestTypeEnum[keyof typeof CreateComplianceJobRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateComplianceJobResponse
 */
export interface CreateComplianceJobResponse {
    /**
     * 
     * @type {ComplianceJob}
     * @memberof CreateComplianceJobResponse
     */
    'data'?: ComplianceJob;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof CreateComplianceJobResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface CreateDmConversationRequest
 */
export interface CreateDmConversationRequest {
    /**
     * The conversation type that is being created.
     * @type {string}
     * @memberof CreateDmConversationRequest
     */
    'conversation_type': CreateDmConversationRequestConversationTypeEnum;
    /**
     * 
     * @type {CreateMessageRequest}
     * @memberof CreateDmConversationRequest
     */
    'message': CreateMessageRequest;
    /**
     * Participants for the DM Conversation.
     * @type {Array<string>}
     * @memberof CreateDmConversationRequest
     */
    'participant_ids': Array<string>;
}

export const CreateDmConversationRequestConversationTypeEnum = {
    Group: 'Group'
} as const;

export type CreateDmConversationRequestConversationTypeEnum = typeof CreateDmConversationRequestConversationTypeEnum[keyof typeof CreateDmConversationRequestConversationTypeEnum];

/**
 * 
 * @export
 * @interface CreateDmEventResponse
 */
export interface CreateDmEventResponse {
    /**
     * 
     * @type {CreateDmEventResponseData}
     * @memberof CreateDmEventResponse
     */
    'data'?: CreateDmEventResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof CreateDmEventResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface CreateDmEventResponseData
 */
export interface CreateDmEventResponseData {
    /**
     * Unique identifier of a DM conversation. This can either be a numeric string, or a pair of numeric strings separated by a \'-\' character in the case of one-on-one DM Conversations.
     * @type {string}
     * @memberof CreateDmEventResponseData
     */
    'dm_conversation_id': string;
    /**
     * Unique identifier of a DM Event.
     * @type {string}
     * @memberof CreateDmEventResponseData
     */
    'dm_event_id': string;
}
/**
 * 
 * @export
 * @interface CreateMessageRequest
 */
export interface CreateMessageRequest {
    /**
     * Attachments to a DM Event.
     * @type {Array<DmMediaAttachment>}
     * @memberof CreateMessageRequest
     */
    'attachments': Array<DmMediaAttachment>;
    /**
     * Text of the message.
     * @type {string}
     * @memberof CreateMessageRequest
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface CreateTextMessageRequest
 */
export interface CreateTextMessageRequest {
    /**
     * Attachments to a DM Event.
     * @type {Array<DmMediaAttachment>}
     * @memberof CreateTextMessageRequest
     */
    'attachments'?: Array<DmMediaAttachment>;
    /**
     * Text of the message.
     * @type {string}
     * @memberof CreateTextMessageRequest
     */
    'text': string;
}
/**
 * A response from deleting user-specified stream filtering rules.
 * @export
 * @interface DeleteRulesRequest
 */
export interface DeleteRulesRequest {
    /**
     * 
     * @type {DeleteRulesRequestDelete}
     * @memberof DeleteRulesRequest
     */
    'delete': DeleteRulesRequestDelete;
}
/**
 * IDs and values of all deleted user-specified stream filtering rules.
 * @export
 * @interface DeleteRulesRequestDelete
 */
export interface DeleteRulesRequestDelete {
    /**
     * IDs of all deleted user-specified stream filtering rules.
     * @type {Array<string>}
     * @memberof DeleteRulesRequestDelete
     */
    'ids'?: Array<string>;
    /**
     * Values of all deleted user-specified stream filtering rules.
     * @type {Array<string>}
     * @memberof DeleteRulesRequestDelete
     */
    'values'?: Array<string>;
}
/**
 * A problem that indicates that the resource requested violates the precepts of this API.
 * @export
 * @interface DisallowedResourceProblem
 */
export interface DisallowedResourceProblem extends Problem {
    /**
     * 
     * @type {string}
     * @memberof DisallowedResourceProblem
     */
    'resource_id': string;
    /**
     * 
     * @type {string}
     * @memberof DisallowedResourceProblem
     */
    'resource_type': DisallowedResourceProblemResourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DisallowedResourceProblem
     */
    'section': DisallowedResourceProblemSectionEnum;
}

export const DisallowedResourceProblemResourceTypeEnum = {
    User: 'user',
    Tweet: 'tweet',
    Media: 'media',
    List: 'list',
    Space: 'space'
} as const;

export type DisallowedResourceProblemResourceTypeEnum = typeof DisallowedResourceProblemResourceTypeEnum[keyof typeof DisallowedResourceProblemResourceTypeEnum];
export const DisallowedResourceProblemSectionEnum = {
    Data: 'data',
    Includes: 'includes'
} as const;

export type DisallowedResourceProblemSectionEnum = typeof DisallowedResourceProblemSectionEnum[keyof typeof DisallowedResourceProblemSectionEnum];

/**
 * 
 * @export
 * @interface DisallowedResourceProblemAllOf
 */
export interface DisallowedResourceProblemAllOf {
    /**
     * 
     * @type {string}
     * @memberof DisallowedResourceProblemAllOf
     */
    'resource_id': string;
    /**
     * 
     * @type {string}
     * @memberof DisallowedResourceProblemAllOf
     */
    'resource_type': DisallowedResourceProblemAllOfResourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DisallowedResourceProblemAllOf
     */
    'section': DisallowedResourceProblemAllOfSectionEnum;
}

export const DisallowedResourceProblemAllOfResourceTypeEnum = {
    User: 'user',
    Tweet: 'tweet',
    Media: 'media',
    List: 'list',
    Space: 'space'
} as const;

export type DisallowedResourceProblemAllOfResourceTypeEnum = typeof DisallowedResourceProblemAllOfResourceTypeEnum[keyof typeof DisallowedResourceProblemAllOfResourceTypeEnum];
export const DisallowedResourceProblemAllOfSectionEnum = {
    Data: 'data',
    Includes: 'includes'
} as const;

export type DisallowedResourceProblemAllOfSectionEnum = typeof DisallowedResourceProblemAllOfSectionEnum[keyof typeof DisallowedResourceProblemAllOfSectionEnum];

/**
 * 
 * @export
 * @interface DmEvent
 */
export interface DmEvent {
    /**
     * 
     * @type {DmEventAttachments}
     * @memberof DmEvent
     */
    'attachments'?: DmEventAttachments;
    /**
     * 
     * @type {string}
     * @memberof DmEvent
     */
    'created_at'?: string;
    /**
     * Unique identifier of a DM conversation. This can either be a numeric string, or a pair of numeric strings separated by a \'-\' character in the case of one-on-one DM Conversations.
     * @type {string}
     * @memberof DmEvent
     */
    'dm_conversation_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DmEvent
     */
    'event_type': string;
    /**
     * Unique identifier of a DM Event.
     * @type {string}
     * @memberof DmEvent
     */
    'id': string;
    /**
     * A list of participants for a ParticipantsJoin or ParticipantsLeave event_type.
     * @type {Array<string>}
     * @memberof DmEvent
     */
    'participant_ids'?: Array<string>;
    /**
     * A list of Tweets this DM refers to.
     * @type {Array<DmEventReferencedTweetsInner>}
     * @memberof DmEvent
     */
    'referenced_tweets'?: Array<DmEventReferencedTweetsInner>;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof DmEvent
     */
    'sender_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DmEvent
     */
    'text'?: string;
}
/**
 * Specifies the type of attachments (if any) present in this DM.
 * @export
 * @interface DmEventAttachments
 */
export interface DmEventAttachments {
    /**
     * A list of card IDs (if cards are attached).
     * @type {Array<string>}
     * @memberof DmEventAttachments
     */
    'card_ids'?: Array<string>;
    /**
     * A list of Media Keys for each one of the media attachments (if media are attached).
     * @type {Array<string>}
     * @memberof DmEventAttachments
     */
    'media_keys'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DmEventReferencedTweetsInner
 */
export interface DmEventReferencedTweetsInner {
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof DmEventReferencedTweetsInner
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface DmMediaAttachment
 */
export interface DmMediaAttachment {
    /**
     * The unique identifier of this Media.
     * @type {string}
     * @memberof DmMediaAttachment
     */
    'media_id': string;
}
/**
 * The rule you have submitted is a duplicate.
 * @export
 * @interface DuplicateRuleProblem
 */
export interface DuplicateRuleProblem extends Problem {
    /**
     * 
     * @type {string}
     * @memberof DuplicateRuleProblem
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DuplicateRuleProblem
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface DuplicateRuleProblemAllOf
 */
export interface DuplicateRuleProblemAllOf {
    /**
     * 
     * @type {string}
     * @memberof DuplicateRuleProblemAllOf
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DuplicateRuleProblemAllOf
     */
    'value'?: string;
}
/**
 * Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is exclusive.
 * @export
 * @interface EntityIndicesInclusiveExclusive
 */
export interface EntityIndicesInclusiveExclusive {
    /**
     * Index (zero-based) at which position this entity ends.  The index is exclusive.
     * @type {number}
     * @memberof EntityIndicesInclusiveExclusive
     */
    'end': number;
    /**
     * Index (zero-based) at which position this entity starts.  The index is inclusive.
     * @type {number}
     * @memberof EntityIndicesInclusiveExclusive
     */
    'start': number;
}
/**
 * Represent a boundary range (start and end index) for a recognized entity (for example a hashtag or a mention). `start` must be smaller than `end`.  The start index is inclusive, the end index is inclusive.
 * @export
 * @interface EntityIndicesInclusiveInclusive
 */
export interface EntityIndicesInclusiveInclusive {
    /**
     * Index (zero-based) at which position this entity ends.  The index is inclusive.
     * @type {number}
     * @memberof EntityIndicesInclusiveInclusive
     */
    'end': number;
    /**
     * Index (zero-based) at which position this entity starts.  The index is inclusive.
     * @type {number}
     * @memberof EntityIndicesInclusiveInclusive
     */
    'start': number;
}
/**
 * 
 * @export
 * @interface Expansions
 */
export interface Expansions {
    /**
     * 
     * @type {Array<Media>}
     * @memberof Expansions
     */
    'media'?: Array<Media>;
    /**
     * 
     * @type {Array<Place>}
     * @memberof Expansions
     */
    'places'?: Array<Place>;
    /**
     * 
     * @type {Array<Poll>}
     * @memberof Expansions
     */
    'polls'?: Array<Poll>;
    /**
     * 
     * @type {Array<Topic>}
     * @memberof Expansions
     */
    'topics'?: Array<Topic>;
    /**
     * 
     * @type {Array<Tweet>}
     * @memberof Expansions
     */
    'tweets'?: Array<Tweet>;
    /**
     * 
     * @type {Array<User>}
     * @memberof Expansions
     */
    'users'?: Array<User>;
}
/**
 * A problem that indicates that you are not allowed to see a particular field on a Tweet, User, etc.
 * @export
 * @interface FieldUnauthorizedProblem
 */
export interface FieldUnauthorizedProblem extends Problem {
    /**
     * 
     * @type {string}
     * @memberof FieldUnauthorizedProblem
     */
    'field': string;
    /**
     * 
     * @type {string}
     * @memberof FieldUnauthorizedProblem
     */
    'resource_type': FieldUnauthorizedProblemResourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FieldUnauthorizedProblem
     */
    'section': FieldUnauthorizedProblemSectionEnum;
}

export const FieldUnauthorizedProblemResourceTypeEnum = {
    User: 'user',
    Tweet: 'tweet',
    Media: 'media',
    List: 'list',
    Space: 'space'
} as const;

export type FieldUnauthorizedProblemResourceTypeEnum = typeof FieldUnauthorizedProblemResourceTypeEnum[keyof typeof FieldUnauthorizedProblemResourceTypeEnum];
export const FieldUnauthorizedProblemSectionEnum = {
    Data: 'data',
    Includes: 'includes'
} as const;

export type FieldUnauthorizedProblemSectionEnum = typeof FieldUnauthorizedProblemSectionEnum[keyof typeof FieldUnauthorizedProblemSectionEnum];

/**
 * 
 * @export
 * @interface FieldUnauthorizedProblemAllOf
 */
export interface FieldUnauthorizedProblemAllOf {
    /**
     * 
     * @type {string}
     * @memberof FieldUnauthorizedProblemAllOf
     */
    'field': string;
    /**
     * 
     * @type {string}
     * @memberof FieldUnauthorizedProblemAllOf
     */
    'resource_type': FieldUnauthorizedProblemAllOfResourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FieldUnauthorizedProblemAllOf
     */
    'section': FieldUnauthorizedProblemAllOfSectionEnum;
}

export const FieldUnauthorizedProblemAllOfResourceTypeEnum = {
    User: 'user',
    Tweet: 'tweet',
    Media: 'media',
    List: 'list',
    Space: 'space'
} as const;

export type FieldUnauthorizedProblemAllOfResourceTypeEnum = typeof FieldUnauthorizedProblemAllOfResourceTypeEnum[keyof typeof FieldUnauthorizedProblemAllOfResourceTypeEnum];
export const FieldUnauthorizedProblemAllOfSectionEnum = {
    Data: 'data',
    Includes: 'includes'
} as const;

export type FieldUnauthorizedProblemAllOfSectionEnum = typeof FieldUnauthorizedProblemAllOfSectionEnum[keyof typeof FieldUnauthorizedProblemAllOfSectionEnum];

/**
 * A Tweet or error that can be returned by the streaming Tweet API. The values returned with a successful streamed Tweet includes the user provided rules that the Tweet matched.
 * @export
 * @interface FilteredStreamingTweetResponse
 */
export interface FilteredStreamingTweetResponse {
    /**
     * 
     * @type {Tweet}
     * @memberof FilteredStreamingTweetResponse
     */
    'data'?: Tweet;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof FilteredStreamingTweetResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof FilteredStreamingTweetResponse
     */
    'includes'?: Expansions;
    /**
     * The list of rules which matched the Tweet
     * @type {Array<FilteredStreamingTweetResponseMatchingRulesInner>}
     * @memberof FilteredStreamingTweetResponse
     */
    'matching_rules'?: Array<FilteredStreamingTweetResponseMatchingRulesInner>;
}
/**
 * 
 * @export
 * @interface FilteredStreamingTweetResponseMatchingRulesInner
 */
export interface FilteredStreamingTweetResponseMatchingRulesInner {
    /**
     * Unique identifier of this rule.
     * @type {string}
     * @memberof FilteredStreamingTweetResponseMatchingRulesInner
     */
    'id': string;
    /**
     * A tag meant for the labeling of user provided rules.
     * @type {string}
     * @memberof FilteredStreamingTweetResponseMatchingRulesInner
     */
    'tag'?: string;
}
/**
 * 
 * @export
 * @interface FullTextEntities
 */
export interface FullTextEntities {
    /**
     * 
     * @type {Array<FullTextEntitiesAnnotationsInner>}
     * @memberof FullTextEntities
     */
    'annotations'?: Array<FullTextEntitiesAnnotationsInner>;
    /**
     * 
     * @type {Array<CashtagEntity>}
     * @memberof FullTextEntities
     */
    'cashtags'?: Array<CashtagEntity>;
    /**
     * 
     * @type {Array<HashtagEntity>}
     * @memberof FullTextEntities
     */
    'hashtags'?: Array<HashtagEntity>;
    /**
     * 
     * @type {Array<MentionEntity>}
     * @memberof FullTextEntities
     */
    'mentions'?: Array<MentionEntity>;
    /**
     * 
     * @type {Array<UrlEntity>}
     * @memberof FullTextEntities
     */
    'urls'?: Array<UrlEntity>;
}
/**
 * Annotation for entities based on the Tweet text.
 * @export
 * @interface FullTextEntitiesAnnotationsInner
 */
export interface FullTextEntitiesAnnotationsInner {
    /**
     * Index (zero-based) at which position this entity ends.  The index is inclusive.
     * @type {number}
     * @memberof FullTextEntitiesAnnotationsInner
     */
    'end': number;
    /**
     * Index (zero-based) at which position this entity starts.  The index is inclusive.
     * @type {number}
     * @memberof FullTextEntitiesAnnotationsInner
     */
    'start': number;
    /**
     * Text used to determine annotation.
     * @type {string}
     * @memberof FullTextEntitiesAnnotationsInner
     */
    'normalized_text'?: string;
    /**
     * Confidence factor for annotation type.
     * @type {number}
     * @memberof FullTextEntitiesAnnotationsInner
     */
    'probability'?: number;
    /**
     * Annotation type.
     * @type {string}
     * @memberof FullTextEntitiesAnnotationsInner
     */
    'type'?: string;
}
/**
 * Represents the data for the annotation.
 * @export
 * @interface FullTextEntitiesAnnotationsInnerAllOf
 */
export interface FullTextEntitiesAnnotationsInnerAllOf {
    /**
     * Text used to determine annotation.
     * @type {string}
     * @memberof FullTextEntitiesAnnotationsInnerAllOf
     */
    'normalized_text'?: string;
    /**
     * Confidence factor for annotation type.
     * @type {number}
     * @memberof FullTextEntitiesAnnotationsInnerAllOf
     */
    'probability'?: number;
    /**
     * Annotation type.
     * @type {string}
     * @memberof FullTextEntitiesAnnotationsInnerAllOf
     */
    'type'?: string;
}
/**
 * A generic problem with no additional information beyond that provided by the HTTP status code.
 * @export
 * @interface GenericProblem
 */
export interface GenericProblem extends Problem {
}
/**
 * 
 * @export
 * @interface Geo
 */
export interface Geo {
    /**
     * 
     * @type {Array<number>}
     * @memberof Geo
     */
    'bbox': Array<number>;
    /**
     * 
     * @type {Point}
     * @memberof Geo
     */
    'geometry'?: Point;
    /**
     * 
     * @type {object}
     * @memberof Geo
     */
    'properties': object;
    /**
     * 
     * @type {string}
     * @memberof Geo
     */
    'type': GeoTypeEnum;
}

export const GeoTypeEnum = {
    Feature: 'Feature'
} as const;

export type GeoTypeEnum = typeof GeoTypeEnum[keyof typeof GeoTypeEnum];

/**
 * 
 * @export
 * @interface Get2ComplianceJobsIdResponse
 */
export interface Get2ComplianceJobsIdResponse {
    /**
     * 
     * @type {ComplianceJob}
     * @memberof Get2ComplianceJobsIdResponse
     */
    'data'?: ComplianceJob;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2ComplianceJobsIdResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface Get2ComplianceJobsResponse
 */
export interface Get2ComplianceJobsResponse {
    /**
     * 
     * @type {Array<ComplianceJob>}
     * @memberof Get2ComplianceJobsResponse
     */
    'data'?: Array<ComplianceJob>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2ComplianceJobsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Get2ComplianceJobsResponseMeta}
     * @memberof Get2ComplianceJobsResponse
     */
    'meta'?: Get2ComplianceJobsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2ComplianceJobsResponseMeta
 */
export interface Get2ComplianceJobsResponseMeta {
    /**
     * The number of results returned in this response.
     * @type {number}
     * @memberof Get2ComplianceJobsResponseMeta
     */
    'result_count'?: number;
}
/**
 * 
 * @export
 * @interface Get2DmConversationsIdDmEventsResponse
 */
export interface Get2DmConversationsIdDmEventsResponse {
    /**
     * 
     * @type {Array<DmEvent>}
     * @memberof Get2DmConversationsIdDmEventsResponse
     */
    'data'?: Array<DmEvent>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2DmConversationsIdDmEventsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2DmConversationsIdDmEventsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2DmConversationsIdDmEventsResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2DmConversationsIdDmEventsResponseMeta
 */
export interface Get2DmConversationsIdDmEventsResponseMeta {
    /**
     * The next token.
     * @type {string}
     * @memberof Get2DmConversationsIdDmEventsResponseMeta
     */
    'next_token'?: string;
    /**
     * The previous token.
     * @type {string}
     * @memberof Get2DmConversationsIdDmEventsResponseMeta
     */
    'previous_token'?: string;
    /**
     * The number of results returned in this response.
     * @type {number}
     * @memberof Get2DmConversationsIdDmEventsResponseMeta
     */
    'result_count'?: number;
}
/**
 * 
 * @export
 * @interface Get2DmConversationsWithParticipantIdDmEventsResponse
 */
export interface Get2DmConversationsWithParticipantIdDmEventsResponse {
    /**
     * 
     * @type {Array<DmEvent>}
     * @memberof Get2DmConversationsWithParticipantIdDmEventsResponse
     */
    'data'?: Array<DmEvent>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2DmConversationsWithParticipantIdDmEventsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2DmConversationsWithParticipantIdDmEventsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2DmConversationsWithParticipantIdDmEventsResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2DmEventsResponse
 */
export interface Get2DmEventsResponse {
    /**
     * 
     * @type {Array<DmEvent>}
     * @memberof Get2DmEventsResponse
     */
    'data'?: Array<DmEvent>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2DmEventsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2DmEventsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2DmEventsResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2ListsIdFollowersResponse
 */
export interface Get2ListsIdFollowersResponse {
    /**
     * 
     * @type {Array<User>}
     * @memberof Get2ListsIdFollowersResponse
     */
    'data'?: Array<User>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2ListsIdFollowersResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2ListsIdFollowersResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2ListsIdFollowersResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2ListsIdMembersResponse
 */
export interface Get2ListsIdMembersResponse {
    /**
     * 
     * @type {Array<User>}
     * @memberof Get2ListsIdMembersResponse
     */
    'data'?: Array<User>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2ListsIdMembersResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2ListsIdMembersResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2ListsIdMembersResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2ListsIdResponse
 */
export interface Get2ListsIdResponse {
    /**
     * 
     * @type {List}
     * @memberof Get2ListsIdResponse
     */
    'data'?: List;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2ListsIdResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2ListsIdResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface Get2ListsIdTweetsResponse
 */
export interface Get2ListsIdTweetsResponse {
    /**
     * 
     * @type {Array<Tweet>}
     * @memberof Get2ListsIdTweetsResponse
     */
    'data'?: Array<Tweet>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2ListsIdTweetsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2ListsIdTweetsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2ListsIdTweetsResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2SpacesByCreatorIdsResponse
 */
export interface Get2SpacesByCreatorIdsResponse {
    /**
     * 
     * @type {Array<Space>}
     * @memberof Get2SpacesByCreatorIdsResponse
     */
    'data'?: Array<Space>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2SpacesByCreatorIdsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2SpacesByCreatorIdsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2ComplianceJobsResponseMeta}
     * @memberof Get2SpacesByCreatorIdsResponse
     */
    'meta'?: Get2ComplianceJobsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2SpacesIdBuyersResponse
 */
export interface Get2SpacesIdBuyersResponse {
    /**
     * 
     * @type {Array<User>}
     * @memberof Get2SpacesIdBuyersResponse
     */
    'data'?: Array<User>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2SpacesIdBuyersResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2SpacesIdBuyersResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2SpacesIdBuyersResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2SpacesIdResponse
 */
export interface Get2SpacesIdResponse {
    /**
     * 
     * @type {Space}
     * @memberof Get2SpacesIdResponse
     */
    'data'?: Space;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2SpacesIdResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2SpacesIdResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface Get2SpacesIdTweetsResponse
 */
export interface Get2SpacesIdTweetsResponse {
    /**
     * 
     * @type {Array<Tweet>}
     * @memberof Get2SpacesIdTweetsResponse
     */
    'data'?: Array<Tweet>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2SpacesIdTweetsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2SpacesIdTweetsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2SpacesIdTweetsResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2SpacesResponse
 */
export interface Get2SpacesResponse {
    /**
     * 
     * @type {Array<Space>}
     * @memberof Get2SpacesResponse
     */
    'data'?: Array<Space>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2SpacesResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2SpacesResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface Get2SpacesSearchResponse
 */
export interface Get2SpacesSearchResponse {
    /**
     * 
     * @type {Array<Space>}
     * @memberof Get2SpacesSearchResponse
     */
    'data'?: Array<Space>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2SpacesSearchResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2SpacesSearchResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2ComplianceJobsResponseMeta}
     * @memberof Get2SpacesSearchResponse
     */
    'meta'?: Get2ComplianceJobsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2TweetsCountsAllResponse
 */
export interface Get2TweetsCountsAllResponse {
    /**
     * 
     * @type {Array<SearchCount>}
     * @memberof Get2TweetsCountsAllResponse
     */
    'data'?: Array<SearchCount>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2TweetsCountsAllResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Get2TweetsCountsAllResponseMeta}
     * @memberof Get2TweetsCountsAllResponse
     */
    'meta'?: Get2TweetsCountsAllResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2TweetsCountsAllResponseMeta
 */
export interface Get2TweetsCountsAllResponseMeta {
    /**
     * The newest id in this response.
     * @type {string}
     * @memberof Get2TweetsCountsAllResponseMeta
     */
    'newest_id'?: string;
    /**
     * The next token.
     * @type {string}
     * @memberof Get2TweetsCountsAllResponseMeta
     */
    'next_token'?: string;
    /**
     * The oldest id in this response.
     * @type {string}
     * @memberof Get2TweetsCountsAllResponseMeta
     */
    'oldest_id'?: string;
    /**
     * The sum of results returned in this response.
     * @type {number}
     * @memberof Get2TweetsCountsAllResponseMeta
     */
    'total_tweet_count'?: number;
}
/**
 * 
 * @export
 * @interface Get2TweetsCountsRecentResponse
 */
export interface Get2TweetsCountsRecentResponse {
    /**
     * 
     * @type {Array<SearchCount>}
     * @memberof Get2TweetsCountsRecentResponse
     */
    'data'?: Array<SearchCount>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2TweetsCountsRecentResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Get2TweetsCountsAllResponseMeta}
     * @memberof Get2TweetsCountsRecentResponse
     */
    'meta'?: Get2TweetsCountsAllResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2TweetsFirehoseStreamResponse
 */
export interface Get2TweetsFirehoseStreamResponse {
    /**
     * 
     * @type {Tweet}
     * @memberof Get2TweetsFirehoseStreamResponse
     */
    'data'?: Tweet;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2TweetsFirehoseStreamResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2TweetsFirehoseStreamResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface Get2TweetsIdLikingUsersResponse
 */
export interface Get2TweetsIdLikingUsersResponse {
    /**
     * 
     * @type {Array<User>}
     * @memberof Get2TweetsIdLikingUsersResponse
     */
    'data'?: Array<User>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2TweetsIdLikingUsersResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2TweetsIdLikingUsersResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2TweetsIdLikingUsersResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2TweetsIdQuoteTweetsResponse
 */
export interface Get2TweetsIdQuoteTweetsResponse {
    /**
     * 
     * @type {Array<Tweet>}
     * @memberof Get2TweetsIdQuoteTweetsResponse
     */
    'data'?: Array<Tweet>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2TweetsIdQuoteTweetsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2TweetsIdQuoteTweetsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2TweetsIdQuoteTweetsResponseMeta}
     * @memberof Get2TweetsIdQuoteTweetsResponse
     */
    'meta'?: Get2TweetsIdQuoteTweetsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2TweetsIdQuoteTweetsResponseMeta
 */
export interface Get2TweetsIdQuoteTweetsResponseMeta {
    /**
     * The next token.
     * @type {string}
     * @memberof Get2TweetsIdQuoteTweetsResponseMeta
     */
    'next_token'?: string;
    /**
     * The number of results returned in this response.
     * @type {number}
     * @memberof Get2TweetsIdQuoteTweetsResponseMeta
     */
    'result_count'?: number;
}
/**
 * 
 * @export
 * @interface Get2TweetsIdResponse
 */
export interface Get2TweetsIdResponse {
    /**
     * 
     * @type {Tweet}
     * @memberof Get2TweetsIdResponse
     */
    'data'?: Tweet;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2TweetsIdResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2TweetsIdResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface Get2TweetsIdRetweetedByResponse
 */
export interface Get2TweetsIdRetweetedByResponse {
    /**
     * 
     * @type {Array<User>}
     * @memberof Get2TweetsIdRetweetedByResponse
     */
    'data'?: Array<User>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2TweetsIdRetweetedByResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2TweetsIdRetweetedByResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2TweetsIdRetweetedByResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2TweetsResponse
 */
export interface Get2TweetsResponse {
    /**
     * 
     * @type {Array<Tweet>}
     * @memberof Get2TweetsResponse
     */
    'data'?: Array<Tweet>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2TweetsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2TweetsResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface Get2TweetsSample10StreamResponse
 */
export interface Get2TweetsSample10StreamResponse {
    /**
     * 
     * @type {Tweet}
     * @memberof Get2TweetsSample10StreamResponse
     */
    'data'?: Tweet;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2TweetsSample10StreamResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2TweetsSample10StreamResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface Get2TweetsSampleStreamResponse
 */
export interface Get2TweetsSampleStreamResponse {
    /**
     * 
     * @type {Tweet}
     * @memberof Get2TweetsSampleStreamResponse
     */
    'data'?: Tweet;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2TweetsSampleStreamResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2TweetsSampleStreamResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface Get2TweetsSearchAllResponse
 */
export interface Get2TweetsSearchAllResponse {
    /**
     * 
     * @type {Array<Tweet>}
     * @memberof Get2TweetsSearchAllResponse
     */
    'data'?: Array<Tweet>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2TweetsSearchAllResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2TweetsSearchAllResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2TweetsSearchAllResponseMeta}
     * @memberof Get2TweetsSearchAllResponse
     */
    'meta'?: Get2TweetsSearchAllResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2TweetsSearchAllResponseMeta
 */
export interface Get2TweetsSearchAllResponseMeta {
    /**
     * The newest id in this response.
     * @type {string}
     * @memberof Get2TweetsSearchAllResponseMeta
     */
    'newest_id'?: string;
    /**
     * The next token.
     * @type {string}
     * @memberof Get2TweetsSearchAllResponseMeta
     */
    'next_token'?: string;
    /**
     * The oldest id in this response.
     * @type {string}
     * @memberof Get2TweetsSearchAllResponseMeta
     */
    'oldest_id'?: string;
    /**
     * The number of results returned in this response.
     * @type {number}
     * @memberof Get2TweetsSearchAllResponseMeta
     */
    'result_count'?: number;
}
/**
 * 
 * @export
 * @interface Get2TweetsSearchRecentResponse
 */
export interface Get2TweetsSearchRecentResponse {
    /**
     * 
     * @type {Array<Tweet>}
     * @memberof Get2TweetsSearchRecentResponse
     */
    'data'?: Array<Tweet>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2TweetsSearchRecentResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2TweetsSearchRecentResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2TweetsSearchAllResponseMeta}
     * @memberof Get2TweetsSearchRecentResponse
     */
    'meta'?: Get2TweetsSearchAllResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2TweetsSearchStreamResponse
 */
export interface Get2TweetsSearchStreamResponse {
    /**
     * 
     * @type {Tweet}
     * @memberof Get2TweetsSearchStreamResponse
     */
    'data'?: Tweet;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2TweetsSearchStreamResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2TweetsSearchStreamResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface Get2UsersByResponse
 */
export interface Get2UsersByResponse {
    /**
     * 
     * @type {Array<User>}
     * @memberof Get2UsersByResponse
     */
    'data'?: Array<User>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersByResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersByResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface Get2UsersByUsernameUsernameResponse
 */
export interface Get2UsersByUsernameUsernameResponse {
    /**
     * 
     * @type {User}
     * @memberof Get2UsersByUsernameUsernameResponse
     */
    'data'?: User;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersByUsernameUsernameResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersByUsernameUsernameResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface Get2UsersIdBlockingResponse
 */
export interface Get2UsersIdBlockingResponse {
    /**
     * 
     * @type {Array<User>}
     * @memberof Get2UsersIdBlockingResponse
     */
    'data'?: Array<User>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdBlockingResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdBlockingResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2UsersIdBlockingResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2UsersIdBookmarksResponse
 */
export interface Get2UsersIdBookmarksResponse {
    /**
     * 
     * @type {Array<Tweet>}
     * @memberof Get2UsersIdBookmarksResponse
     */
    'data'?: Array<Tweet>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdBookmarksResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdBookmarksResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2UsersIdBookmarksResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2UsersIdFollowedListsResponse
 */
export interface Get2UsersIdFollowedListsResponse {
    /**
     * 
     * @type {Array<List>}
     * @memberof Get2UsersIdFollowedListsResponse
     */
    'data'?: Array<List>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdFollowedListsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdFollowedListsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2UsersIdFollowedListsResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2UsersIdFollowersResponse
 */
export interface Get2UsersIdFollowersResponse {
    /**
     * 
     * @type {Array<User>}
     * @memberof Get2UsersIdFollowersResponse
     */
    'data'?: Array<User>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdFollowersResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdFollowersResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2UsersIdFollowersResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2UsersIdFollowingResponse
 */
export interface Get2UsersIdFollowingResponse {
    /**
     * 
     * @type {Array<User>}
     * @memberof Get2UsersIdFollowingResponse
     */
    'data'?: Array<User>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdFollowingResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdFollowingResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2UsersIdFollowingResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2UsersIdLikedTweetsResponse
 */
export interface Get2UsersIdLikedTweetsResponse {
    /**
     * 
     * @type {Array<Tweet>}
     * @memberof Get2UsersIdLikedTweetsResponse
     */
    'data'?: Array<Tweet>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdLikedTweetsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdLikedTweetsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2UsersIdLikedTweetsResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2UsersIdListMembershipsResponse
 */
export interface Get2UsersIdListMembershipsResponse {
    /**
     * 
     * @type {Array<List>}
     * @memberof Get2UsersIdListMembershipsResponse
     */
    'data'?: Array<List>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdListMembershipsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdListMembershipsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2UsersIdListMembershipsResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2UsersIdMentionsResponse
 */
export interface Get2UsersIdMentionsResponse {
    /**
     * 
     * @type {Array<Tweet>}
     * @memberof Get2UsersIdMentionsResponse
     */
    'data'?: Array<Tweet>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdMentionsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdMentionsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2UsersIdMentionsResponseMeta}
     * @memberof Get2UsersIdMentionsResponse
     */
    'meta'?: Get2UsersIdMentionsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2UsersIdMentionsResponseMeta
 */
export interface Get2UsersIdMentionsResponseMeta {
    /**
     * The newest id in this response.
     * @type {string}
     * @memberof Get2UsersIdMentionsResponseMeta
     */
    'newest_id'?: string;
    /**
     * The next token.
     * @type {string}
     * @memberof Get2UsersIdMentionsResponseMeta
     */
    'next_token'?: string;
    /**
     * The oldest id in this response.
     * @type {string}
     * @memberof Get2UsersIdMentionsResponseMeta
     */
    'oldest_id'?: string;
    /**
     * The previous token.
     * @type {string}
     * @memberof Get2UsersIdMentionsResponseMeta
     */
    'previous_token'?: string;
    /**
     * The number of results returned in this response.
     * @type {number}
     * @memberof Get2UsersIdMentionsResponseMeta
     */
    'result_count'?: number;
}
/**
 * 
 * @export
 * @interface Get2UsersIdMutingResponse
 */
export interface Get2UsersIdMutingResponse {
    /**
     * 
     * @type {Array<User>}
     * @memberof Get2UsersIdMutingResponse
     */
    'data'?: Array<User>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdMutingResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdMutingResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2UsersIdMutingResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2UsersIdOwnedListsResponse
 */
export interface Get2UsersIdOwnedListsResponse {
    /**
     * 
     * @type {Array<List>}
     * @memberof Get2UsersIdOwnedListsResponse
     */
    'data'?: Array<List>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdOwnedListsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdOwnedListsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2DmConversationsIdDmEventsResponseMeta}
     * @memberof Get2UsersIdOwnedListsResponse
     */
    'meta'?: Get2DmConversationsIdDmEventsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2UsersIdPinnedListsResponse
 */
export interface Get2UsersIdPinnedListsResponse {
    /**
     * 
     * @type {Array<List>}
     * @memberof Get2UsersIdPinnedListsResponse
     */
    'data'?: Array<List>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdPinnedListsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdPinnedListsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2ComplianceJobsResponseMeta}
     * @memberof Get2UsersIdPinnedListsResponse
     */
    'meta'?: Get2ComplianceJobsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2UsersIdResponse
 */
export interface Get2UsersIdResponse {
    /**
     * 
     * @type {User}
     * @memberof Get2UsersIdResponse
     */
    'data'?: User;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface Get2UsersIdTimelinesReverseChronologicalResponse
 */
export interface Get2UsersIdTimelinesReverseChronologicalResponse {
    /**
     * 
     * @type {Array<Tweet>}
     * @memberof Get2UsersIdTimelinesReverseChronologicalResponse
     */
    'data'?: Array<Tweet>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdTimelinesReverseChronologicalResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdTimelinesReverseChronologicalResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2UsersIdMentionsResponseMeta}
     * @memberof Get2UsersIdTimelinesReverseChronologicalResponse
     */
    'meta'?: Get2UsersIdMentionsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2UsersIdTweetsResponse
 */
export interface Get2UsersIdTweetsResponse {
    /**
     * 
     * @type {Array<Tweet>}
     * @memberof Get2UsersIdTweetsResponse
     */
    'data'?: Array<Tweet>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersIdTweetsResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersIdTweetsResponse
     */
    'includes'?: Expansions;
    /**
     * 
     * @type {Get2UsersIdMentionsResponseMeta}
     * @memberof Get2UsersIdTweetsResponse
     */
    'meta'?: Get2UsersIdMentionsResponseMeta;
}
/**
 * 
 * @export
 * @interface Get2UsersMeResponse
 */
export interface Get2UsersMeResponse {
    /**
     * 
     * @type {User}
     * @memberof Get2UsersMeResponse
     */
    'data'?: User;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersMeResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersMeResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface Get2UsersResponse
 */
export interface Get2UsersResponse {
    /**
     * 
     * @type {Array<User>}
     * @memberof Get2UsersResponse
     */
    'data'?: Array<User>;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof Get2UsersResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof Get2UsersResponse
     */
    'includes'?: Expansions;
}
/**
 * 
 * @export
 * @interface HashtagEntity
 */
export interface HashtagEntity {
    /**
     * Index (zero-based) at which position this entity ends.  The index is exclusive.
     * @type {number}
     * @memberof HashtagEntity
     */
    'end': number;
    /**
     * Index (zero-based) at which position this entity starts.  The index is inclusive.
     * @type {number}
     * @memberof HashtagEntity
     */
    'start': number;
    /**
     * The text of the Hashtag.
     * @type {string}
     * @memberof HashtagEntity
     */
    'tag': string;
}
/**
 * Represent the portion of text recognized as a Hashtag, and its start and end position within the text.
 * @export
 * @interface HashtagFields
 */
export interface HashtagFields {
    /**
     * The text of the Hashtag.
     * @type {string}
     * @memberof HashtagFields
     */
    'tag': string;
}
/**
 * A problem that indicates this request is invalid.
 * @export
 * @interface InvalidRequestProblem
 */
export interface InvalidRequestProblem extends Problem {
    /**
     * 
     * @type {Array<InvalidRequestProblemAllOfErrors>}
     * @memberof InvalidRequestProblem
     */
    'errors'?: Array<InvalidRequestProblemAllOfErrors>;
}
/**
 * 
 * @export
 * @interface InvalidRequestProblemAllOf
 */
export interface InvalidRequestProblemAllOf {
    /**
     * 
     * @type {Array<InvalidRequestProblemAllOfErrors>}
     * @memberof InvalidRequestProblemAllOf
     */
    'errors'?: Array<InvalidRequestProblemAllOfErrors>;
}
/**
 * 
 * @export
 * @interface InvalidRequestProblemAllOfErrors
 */
export interface InvalidRequestProblemAllOfErrors {
    /**
     * 
     * @type {string}
     * @memberof InvalidRequestProblemAllOfErrors
     */
    'message'?: string;
    /**
     * 
     * @type {{ [key: string]: Array<string>; }}
     * @memberof InvalidRequestProblemAllOfErrors
     */
    'parameters'?: { [key: string]: Array<string>; };
}
/**
 * The rule you have submitted is invalid.
 * @export
 * @interface InvalidRuleProblem
 */
export interface InvalidRuleProblem extends Problem {
}
/**
 * A Twitter List is a curated group of accounts.
 * @export
 * @interface List
 */
export interface List {
    /**
     * 
     * @type {string}
     * @memberof List
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof List
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof List
     */
    'follower_count'?: number;
    /**
     * The unique identifier of this List.
     * @type {string}
     * @memberof List
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof List
     */
    'member_count'?: number;
    /**
     * The name of this List.
     * @type {string}
     * @memberof List
     */
    'name': string;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof List
     */
    'owner_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof List
     */
    'private'?: boolean;
}
/**
 * 
 * @export
 * @interface ListAddUserRequest
 */
export interface ListAddUserRequest {
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof ListAddUserRequest
     */
    'user_id': string;
}
/**
 * 
 * @export
 * @interface ListCreateRequest
 */
export interface ListCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ListCreateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ListCreateRequest
     */
    'private'?: boolean;
}
/**
 * 
 * @export
 * @interface ListCreateResponse
 */
export interface ListCreateResponse {
    /**
     * 
     * @type {ListCreateResponseData}
     * @memberof ListCreateResponse
     */
    'data'?: ListCreateResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof ListCreateResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * A Twitter List is a curated group of accounts.
 * @export
 * @interface ListCreateResponseData
 */
export interface ListCreateResponseData {
    /**
     * The unique identifier of this List.
     * @type {string}
     * @memberof ListCreateResponseData
     */
    'id': string;
    /**
     * The name of this List.
     * @type {string}
     * @memberof ListCreateResponseData
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ListDeleteResponse
 */
export interface ListDeleteResponse {
    /**
     * 
     * @type {ListDeleteResponseData}
     * @memberof ListDeleteResponse
     */
    'data'?: ListDeleteResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof ListDeleteResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface ListDeleteResponseData
 */
export interface ListDeleteResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof ListDeleteResponseData
     */
    'deleted'?: boolean;
}
/**
 * 
 * @export
 * @interface ListFollowedRequest
 */
export interface ListFollowedRequest {
    /**
     * The unique identifier of this List.
     * @type {string}
     * @memberof ListFollowedRequest
     */
    'list_id': string;
}
/**
 * 
 * @export
 * @interface ListFollowedResponse
 */
export interface ListFollowedResponse {
    /**
     * 
     * @type {ListFollowedResponseData}
     * @memberof ListFollowedResponse
     */
    'data'?: ListFollowedResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof ListFollowedResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface ListFollowedResponseData
 */
export interface ListFollowedResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof ListFollowedResponseData
     */
    'following'?: boolean;
}
/**
 * 
 * @export
 * @interface ListMutateResponse
 */
export interface ListMutateResponse {
    /**
     * 
     * @type {ListMutateResponseData}
     * @memberof ListMutateResponse
     */
    'data'?: ListMutateResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof ListMutateResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface ListMutateResponseData
 */
export interface ListMutateResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof ListMutateResponseData
     */
    'is_member'?: boolean;
}
/**
 * 
 * @export
 * @interface ListPinnedRequest
 */
export interface ListPinnedRequest {
    /**
     * The unique identifier of this List.
     * @type {string}
     * @memberof ListPinnedRequest
     */
    'list_id': string;
}
/**
 * 
 * @export
 * @interface ListPinnedResponse
 */
export interface ListPinnedResponse {
    /**
     * 
     * @type {ListPinnedResponseData}
     * @memberof ListPinnedResponse
     */
    'data'?: ListPinnedResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof ListPinnedResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface ListPinnedResponseData
 */
export interface ListPinnedResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof ListPinnedResponseData
     */
    'pinned'?: boolean;
}
/**
 * 
 * @export
 * @interface ListUnpinResponse
 */
export interface ListUnpinResponse {
    /**
     * 
     * @type {ListPinnedResponseData}
     * @memberof ListUnpinResponse
     */
    'data'?: ListPinnedResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof ListUnpinResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface ListUpdateRequest
 */
export interface ListUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ListUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ListUpdateRequest
     */
    'private'?: boolean;
}
/**
 * 
 * @export
 * @interface ListUpdateResponse
 */
export interface ListUpdateResponse {
    /**
     * 
     * @type {ListUpdateResponseData}
     * @memberof ListUpdateResponse
     */
    'data'?: ListUpdateResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof ListUpdateResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface ListUpdateResponseData
 */
export interface ListUpdateResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof ListUpdateResponseData
     */
    'updated'?: boolean;
}
/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * The height of the media in pixels.
     * @type {number}
     * @memberof Media
     */
    'height'?: number;
    /**
     * The Media Key identifier for this attachment.
     * @type {string}
     * @memberof Media
     */
    'media_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    'type': string;
    /**
     * The width of the media in pixels.
     * @type {number}
     * @memberof Media
     */
    'width'?: number;
}
/**
 * 
 * @export
 * @interface MentionEntity
 */
export interface MentionEntity {
    /**
     * Index (zero-based) at which position this entity ends.  The index is exclusive.
     * @type {number}
     * @memberof MentionEntity
     */
    'end': number;
    /**
     * Index (zero-based) at which position this entity starts.  The index is inclusive.
     * @type {number}
     * @memberof MentionEntity
     */
    'start': number;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof MentionEntity
     */
    'id'?: string;
    /**
     * The Twitter handle (screen name) of this user.
     * @type {string}
     * @memberof MentionEntity
     */
    'username': string;
}
/**
 * Represent the portion of text recognized as a User mention, and its start and end position within the text.
 * @export
 * @interface MentionFields
 */
export interface MentionFields {
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof MentionFields
     */
    'id'?: string;
    /**
     * The Twitter handle (screen name) of this user.
     * @type {string}
     * @memberof MentionFields
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface MuteUserMutationResponse
 */
export interface MuteUserMutationResponse {
    /**
     * 
     * @type {MuteUserMutationResponseData}
     * @memberof MuteUserMutationResponse
     */
    'data'?: MuteUserMutationResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof MuteUserMutationResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface MuteUserMutationResponseData
 */
export interface MuteUserMutationResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof MuteUserMutationResponseData
     */
    'muting'?: boolean;
}
/**
 * 
 * @export
 * @interface MuteUserRequest
 */
export interface MuteUserRequest {
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof MuteUserRequest
     */
    'target_user_id': string;
}
/**
 * A problem that indicates the user\'s rule set is not compliant.
 * @export
 * @interface NonCompliantRulesProblem
 */
export interface NonCompliantRulesProblem extends Problem {
}
/**
 * A problem that indicates your client application does not have the required OAuth1 permissions for the requested endpoint.
 * @export
 * @interface Oauth1PermissionsProblem
 */
export interface Oauth1PermissionsProblem extends Problem {
}
/**
 * You have been disconnected for operational reasons.
 * @export
 * @interface OperationalDisconnectProblem
 */
export interface OperationalDisconnectProblem extends Problem {
    /**
     * 
     * @type {string}
     * @memberof OperationalDisconnectProblem
     */
    'disconnect_type'?: OperationalDisconnectProblemDisconnectTypeEnum;
}

export const OperationalDisconnectProblemDisconnectTypeEnum = {
    OperationalDisconnect: 'OperationalDisconnect',
    UpstreamOperationalDisconnect: 'UpstreamOperationalDisconnect',
    ForceDisconnect: 'ForceDisconnect',
    UpstreamUncleanDisconnect: 'UpstreamUncleanDisconnect',
    SlowReader: 'SlowReader',
    InternalError: 'InternalError',
    ClientApplicationStateDegraded: 'ClientApplicationStateDegraded',
    InvalidRules: 'InvalidRules'
} as const;

export type OperationalDisconnectProblemDisconnectTypeEnum = typeof OperationalDisconnectProblemDisconnectTypeEnum[keyof typeof OperationalDisconnectProblemDisconnectTypeEnum];

/**
 * 
 * @export
 * @interface OperationalDisconnectProblemAllOf
 */
export interface OperationalDisconnectProblemAllOf {
    /**
     * 
     * @type {string}
     * @memberof OperationalDisconnectProblemAllOf
     */
    'disconnect_type'?: OperationalDisconnectProblemAllOfDisconnectTypeEnum;
}

export const OperationalDisconnectProblemAllOfDisconnectTypeEnum = {
    OperationalDisconnect: 'OperationalDisconnect',
    UpstreamOperationalDisconnect: 'UpstreamOperationalDisconnect',
    ForceDisconnect: 'ForceDisconnect',
    UpstreamUncleanDisconnect: 'UpstreamUncleanDisconnect',
    SlowReader: 'SlowReader',
    InternalError: 'InternalError',
    ClientApplicationStateDegraded: 'ClientApplicationStateDegraded',
    InvalidRules: 'InvalidRules'
} as const;

export type OperationalDisconnectProblemAllOfDisconnectTypeEnum = typeof OperationalDisconnectProblemAllOfDisconnectTypeEnum[keyof typeof OperationalDisconnectProblemAllOfDisconnectTypeEnum];

/**
 * 
 * @export
 * @interface Photo
 */
export interface Photo extends Media {
    /**
     * 
     * @type {string}
     * @memberof Photo
     */
    'alt_text'?: string;
    /**
     * 
     * @type {string}
     * @memberof Photo
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface PhotoAllOf
 */
export interface PhotoAllOf {
    /**
     * 
     * @type {string}
     * @memberof PhotoAllOf
     */
    'alt_text'?: string;
    /**
     * 
     * @type {string}
     * @memberof PhotoAllOf
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface Place
 */
export interface Place {
    /**
     * 
     * @type {Array<string>}
     * @memberof Place
     */
    'contained_within'?: Array<string>;
    /**
     * The full name of the county in which this place exists.
     * @type {string}
     * @memberof Place
     */
    'country'?: string;
    /**
     * A two-letter ISO 3166-1 alpha-2 country code.
     * @type {string}
     * @memberof Place
     */
    'country_code'?: string;
    /**
     * The full name of this place.
     * @type {string}
     * @memberof Place
     */
    'full_name': string;
    /**
     * 
     * @type {Geo}
     * @memberof Place
     */
    'geo'?: Geo;
    /**
     * The identifier for this place.
     * @type {string}
     * @memberof Place
     */
    'id': string;
    /**
     * The human readable name of this place.
     * @type {string}
     * @memberof Place
     */
    'name'?: string;
    /**
     * 
     * @type {PlaceType}
     * @memberof Place
     */
    'place_type'?: PlaceType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const PlaceType = {
    Poi: 'poi',
    Neighborhood: 'neighborhood',
    City: 'city',
    Admin: 'admin',
    Country: 'country',
    Unknown: 'unknown'
} as const;

export type PlaceType = typeof PlaceType[keyof typeof PlaceType];


/**
 * A [GeoJson Point](https://tools.ietf.org/html/rfc7946#section-3.1.2) geometry object.
 * @export
 * @interface Point
 */
export interface Point {
    /**
     * A [GeoJson Position](https://tools.ietf.org/html/rfc7946#section-3.1.1) in the format `[longitude,latitude]`.
     * @type {Array<number>}
     * @memberof Point
     */
    'coordinates': Array<number>;
    /**
     * 
     * @type {string}
     * @memberof Point
     */
    'type': PointTypeEnum;
}

export const PointTypeEnum = {
    Point: 'Point'
} as const;

export type PointTypeEnum = typeof PointTypeEnum[keyof typeof PointTypeEnum];

/**
 * Represent a Poll attached to a Tweet.
 * @export
 * @interface Poll
 */
export interface Poll {
    /**
     * 
     * @type {number}
     * @memberof Poll
     */
    'duration_minutes'?: number;
    /**
     * 
     * @type {string}
     * @memberof Poll
     */
    'end_datetime'?: string;
    /**
     * Unique identifier of this poll.
     * @type {string}
     * @memberof Poll
     */
    'id': string;
    /**
     * 
     * @type {Array<PollOption>}
     * @memberof Poll
     */
    'options': Array<PollOption>;
    /**
     * 
     * @type {string}
     * @memberof Poll
     */
    'voting_status'?: PollVotingStatusEnum;
}

export const PollVotingStatusEnum = {
    Open: 'open',
    Closed: 'closed'
} as const;

export type PollVotingStatusEnum = typeof PollVotingStatusEnum[keyof typeof PollVotingStatusEnum];

/**
 * Describes a choice in a Poll object.
 * @export
 * @interface PollOption
 */
export interface PollOption {
    /**
     * The text of a poll choice.
     * @type {string}
     * @memberof PollOption
     */
    'label': string;
    /**
     * Position of this choice in the poll.
     * @type {number}
     * @memberof PollOption
     */
    'position': number;
    /**
     * Number of users who voted for this choice.
     * @type {number}
     * @memberof PollOption
     */
    'votes': number;
}
/**
 * An HTTP Problem Details object, as defined in IETF RFC 7807 (https://tools.ietf.org/html/rfc7807).
 * @export
 * @interface Problem
 */
export interface Problem {
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'detail'?: string;
    /**
     * 
     * @type {number}
     * @memberof Problem
     */
    'status'?: number;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Problem
     */
    'type': string;
}
/**
 * Shows who can reply a Tweet. Fields returned are everyone, mentioned_users, and following.
 * @export
 * @enum {string}
 */

export const ReplySettings = {
    Everyone: 'everyone',
    MentionedUsers: 'mentionedUsers',
    Following: 'following',
    Other: 'other'
} as const;

export type ReplySettings = typeof ReplySettings[keyof typeof ReplySettings];


/**
 * A problem that indicates that a given Tweet, User, etc. does not exist.
 * @export
 * @interface ResourceNotFoundProblem
 */
export interface ResourceNotFoundProblem extends Problem {
    /**
     * 
     * @type {string}
     * @memberof ResourceNotFoundProblem
     */
    'parameter': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceNotFoundProblem
     */
    'resource_id': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceNotFoundProblem
     */
    'resource_type': ResourceNotFoundProblemResourceTypeEnum;
    /**
     * Value will match the schema of the field.
     * @type {string}
     * @memberof ResourceNotFoundProblem
     */
    'value': string;
}

export const ResourceNotFoundProblemResourceTypeEnum = {
    User: 'user',
    Tweet: 'tweet',
    Media: 'media',
    List: 'list',
    Space: 'space'
} as const;

export type ResourceNotFoundProblemResourceTypeEnum = typeof ResourceNotFoundProblemResourceTypeEnum[keyof typeof ResourceNotFoundProblemResourceTypeEnum];

/**
 * 
 * @export
 * @interface ResourceNotFoundProblemAllOf
 */
export interface ResourceNotFoundProblemAllOf {
    /**
     * 
     * @type {string}
     * @memberof ResourceNotFoundProblemAllOf
     */
    'parameter': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceNotFoundProblemAllOf
     */
    'resource_id': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceNotFoundProblemAllOf
     */
    'resource_type': ResourceNotFoundProblemAllOfResourceTypeEnum;
    /**
     * Value will match the schema of the field.
     * @type {string}
     * @memberof ResourceNotFoundProblemAllOf
     */
    'value': string;
}

export const ResourceNotFoundProblemAllOfResourceTypeEnum = {
    User: 'user',
    Tweet: 'tweet',
    Media: 'media',
    List: 'list',
    Space: 'space'
} as const;

export type ResourceNotFoundProblemAllOfResourceTypeEnum = typeof ResourceNotFoundProblemAllOfResourceTypeEnum[keyof typeof ResourceNotFoundProblemAllOfResourceTypeEnum];

/**
 * A problem that indicates you are not allowed to see a particular Tweet, User, etc.
 * @export
 * @interface ResourceUnauthorizedProblem
 */
export interface ResourceUnauthorizedProblem extends Problem {
    /**
     * 
     * @type {string}
     * @memberof ResourceUnauthorizedProblem
     */
    'parameter': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceUnauthorizedProblem
     */
    'resource_id': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceUnauthorizedProblem
     */
    'resource_type': ResourceUnauthorizedProblemResourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ResourceUnauthorizedProblem
     */
    'section': ResourceUnauthorizedProblemSectionEnum;
    /**
     * 
     * @type {string}
     * @memberof ResourceUnauthorizedProblem
     */
    'value': string;
}

export const ResourceUnauthorizedProblemResourceTypeEnum = {
    User: 'user',
    Tweet: 'tweet',
    Media: 'media',
    List: 'list',
    Space: 'space'
} as const;

export type ResourceUnauthorizedProblemResourceTypeEnum = typeof ResourceUnauthorizedProblemResourceTypeEnum[keyof typeof ResourceUnauthorizedProblemResourceTypeEnum];
export const ResourceUnauthorizedProblemSectionEnum = {
    Data: 'data',
    Includes: 'includes'
} as const;

export type ResourceUnauthorizedProblemSectionEnum = typeof ResourceUnauthorizedProblemSectionEnum[keyof typeof ResourceUnauthorizedProblemSectionEnum];

/**
 * 
 * @export
 * @interface ResourceUnauthorizedProblemAllOf
 */
export interface ResourceUnauthorizedProblemAllOf {
    /**
     * 
     * @type {string}
     * @memberof ResourceUnauthorizedProblemAllOf
     */
    'parameter': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceUnauthorizedProblemAllOf
     */
    'resource_id': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceUnauthorizedProblemAllOf
     */
    'resource_type': ResourceUnauthorizedProblemAllOfResourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ResourceUnauthorizedProblemAllOf
     */
    'section': ResourceUnauthorizedProblemAllOfSectionEnum;
    /**
     * 
     * @type {string}
     * @memberof ResourceUnauthorizedProblemAllOf
     */
    'value': string;
}

export const ResourceUnauthorizedProblemAllOfResourceTypeEnum = {
    User: 'user',
    Tweet: 'tweet',
    Media: 'media',
    List: 'list',
    Space: 'space'
} as const;

export type ResourceUnauthorizedProblemAllOfResourceTypeEnum = typeof ResourceUnauthorizedProblemAllOfResourceTypeEnum[keyof typeof ResourceUnauthorizedProblemAllOfResourceTypeEnum];
export const ResourceUnauthorizedProblemAllOfSectionEnum = {
    Data: 'data',
    Includes: 'includes'
} as const;

export type ResourceUnauthorizedProblemAllOfSectionEnum = typeof ResourceUnauthorizedProblemAllOfSectionEnum[keyof typeof ResourceUnauthorizedProblemAllOfSectionEnum];

/**
 * A problem that indicates a particular Tweet, User, etc. is not available to you.
 * @export
 * @interface ResourceUnavailableProblem
 */
export interface ResourceUnavailableProblem extends Problem {
    /**
     * 
     * @type {string}
     * @memberof ResourceUnavailableProblem
     */
    'parameter': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceUnavailableProblem
     */
    'resource_id': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceUnavailableProblem
     */
    'resource_type': ResourceUnavailableProblemResourceTypeEnum;
}

export const ResourceUnavailableProblemResourceTypeEnum = {
    User: 'user',
    Tweet: 'tweet',
    Media: 'media',
    List: 'list',
    Space: 'space'
} as const;

export type ResourceUnavailableProblemResourceTypeEnum = typeof ResourceUnavailableProblemResourceTypeEnum[keyof typeof ResourceUnavailableProblemResourceTypeEnum];

/**
 * 
 * @export
 * @interface ResourceUnavailableProblemAllOf
 */
export interface ResourceUnavailableProblemAllOf {
    /**
     * 
     * @type {string}
     * @memberof ResourceUnavailableProblemAllOf
     */
    'parameter': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceUnavailableProblemAllOf
     */
    'resource_id': string;
    /**
     * 
     * @type {string}
     * @memberof ResourceUnavailableProblemAllOf
     */
    'resource_type': ResourceUnavailableProblemAllOfResourceTypeEnum;
}

export const ResourceUnavailableProblemAllOfResourceTypeEnum = {
    User: 'user',
    Tweet: 'tweet',
    Media: 'media',
    List: 'list',
    Space: 'space'
} as const;

export type ResourceUnavailableProblemAllOfResourceTypeEnum = typeof ResourceUnavailableProblemAllOfResourceTypeEnum[keyof typeof ResourceUnavailableProblemAllOfResourceTypeEnum];

/**
 * A user-provided stream filtering rule.
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * Unique identifier of this rule.
     * @type {string}
     * @memberof Rule
     */
    'id'?: string;
    /**
     * A tag meant for the labeling of user provided rules.
     * @type {string}
     * @memberof Rule
     */
    'tag'?: string;
    /**
     * The filterlang value of the rule.
     * @type {string}
     * @memberof Rule
     */
    'value': string;
}
/**
 * A user-provided stream filtering rule.
 * @export
 * @interface RuleNoId
 */
export interface RuleNoId {
    /**
     * A tag meant for the labeling of user provided rules.
     * @type {string}
     * @memberof RuleNoId
     */
    'tag'?: string;
    /**
     * The filterlang value of the rule.
     * @type {string}
     * @memberof RuleNoId
     */
    'value': string;
}
/**
 * You have exceeded the maximum number of rules.
 * @export
 * @interface RulesCapProblem
 */
export interface RulesCapProblem extends Problem {
}
/**
 * 
 * @export
 * @interface RulesLookupResponse
 */
export interface RulesLookupResponse {
    /**
     * 
     * @type {Array<Rule>}
     * @memberof RulesLookupResponse
     */
    'data'?: Array<Rule>;
    /**
     * 
     * @type {RulesResponseMetadata}
     * @memberof RulesLookupResponse
     */
    'meta': RulesResponseMetadata;
}
/**
 * @type RulesRequestSummary
 * @export
 */
export type RulesRequestSummary = RulesRequestSummaryOneOf | RulesRequestSummaryOneOf1;

/**
 * A summary of the results of the addition of user-specified stream filtering rules.
 * @export
 * @interface RulesRequestSummaryOneOf
 */
export interface RulesRequestSummaryOneOf {
    /**
     * Number of user-specified stream filtering rules that were created.
     * @type {number}
     * @memberof RulesRequestSummaryOneOf
     */
    'created': number;
    /**
     * Number of invalid user-specified stream filtering rules.
     * @type {number}
     * @memberof RulesRequestSummaryOneOf
     */
    'invalid': number;
    /**
     * Number of user-specified stream filtering rules that were not created.
     * @type {number}
     * @memberof RulesRequestSummaryOneOf
     */
    'not_created': number;
    /**
     * Number of valid user-specified stream filtering rules.
     * @type {number}
     * @memberof RulesRequestSummaryOneOf
     */
    'valid': number;
}
/**
 * 
 * @export
 * @interface RulesRequestSummaryOneOf1
 */
export interface RulesRequestSummaryOneOf1 {
    /**
     * Number of user-specified stream filtering rules that were deleted.
     * @type {number}
     * @memberof RulesRequestSummaryOneOf1
     */
    'deleted': number;
    /**
     * Number of user-specified stream filtering rules that were not deleted.
     * @type {number}
     * @memberof RulesRequestSummaryOneOf1
     */
    'not_deleted': number;
}
/**
 * 
 * @export
 * @interface RulesResponseMetadata
 */
export interface RulesResponseMetadata {
    /**
     * The next token.
     * @type {string}
     * @memberof RulesResponseMetadata
     */
    'next_token'?: string;
    /**
     * Number of Rules in result set.
     * @type {number}
     * @memberof RulesResponseMetadata
     */
    'result_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof RulesResponseMetadata
     */
    'sent': string;
    /**
     * 
     * @type {RulesRequestSummary}
     * @memberof RulesResponseMetadata
     */
    'summary'?: RulesRequestSummary;
}
/**
 * Represent a Search Count Result.
 * @export
 * @interface SearchCount
 */
export interface SearchCount {
    /**
     * The end time of the bucket.
     * @type {string}
     * @memberof SearchCount
     */
    'end': string;
    /**
     * The start time of the bucket.
     * @type {string}
     * @memberof SearchCount
     */
    'start': string;
    /**
     * The count for the bucket.
     * @type {number}
     * @memberof SearchCount
     */
    'tweet_count': number;
}
/**
 * 
 * @export
 * @interface Space
 */
export interface Space {
    /**
     * Creation time of the Space.
     * @type {string}
     * @memberof Space
     */
    'created_at'?: string;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof Space
     */
    'creator_id'?: string;
    /**
     * End time of the Space.
     * @type {string}
     * @memberof Space
     */
    'ended_at'?: string;
    /**
     * The user ids for the hosts of the Space.
     * @type {Array<string>}
     * @memberof Space
     */
    'host_ids'?: Array<string>;
    /**
     * The unique identifier of this Space.
     * @type {string}
     * @memberof Space
     */
    'id': string;
    /**
     * An array of user ids for people who were invited to a Space.
     * @type {Array<string>}
     * @memberof Space
     */
    'invited_user_ids'?: Array<string>;
    /**
     * Denotes if the Space is a ticketed Space.
     * @type {boolean}
     * @memberof Space
     */
    'is_ticketed'?: boolean;
    /**
     * The language of the Space.
     * @type {string}
     * @memberof Space
     */
    'lang'?: string;
    /**
     * The number of participants in a Space.
     * @type {number}
     * @memberof Space
     */
    'participant_count'?: number;
    /**
     * A date time stamp for when a Space is scheduled to begin.
     * @type {string}
     * @memberof Space
     */
    'scheduled_start'?: string;
    /**
     * An array of user ids for people who were speakers in a Space.
     * @type {Array<string>}
     * @memberof Space
     */
    'speaker_ids'?: Array<string>;
    /**
     * When the Space was started as a date string.
     * @type {string}
     * @memberof Space
     */
    'started_at'?: string;
    /**
     * The current state of the Space.
     * @type {string}
     * @memberof Space
     */
    'state': SpaceStateEnum;
    /**
     * The number of people who have either purchased a ticket or set a reminder for this Space.
     * @type {number}
     * @memberof Space
     */
    'subscriber_count'?: number;
    /**
     * The title of the Space.
     * @type {string}
     * @memberof Space
     */
    'title'?: string;
    /**
     * The topics of a Space, as selected by its creator.
     * @type {Array<SpaceTopicsInner>}
     * @memberof Space
     */
    'topics'?: Array<SpaceTopicsInner>;
    /**
     * When the Space was last updated.
     * @type {string}
     * @memberof Space
     */
    'updated_at'?: string;
}

export const SpaceStateEnum = {
    Live: 'live',
    Scheduled: 'scheduled',
    Ended: 'ended'
} as const;

export type SpaceStateEnum = typeof SpaceStateEnum[keyof typeof SpaceStateEnum];

/**
 * The Twitter Topic object.
 * @export
 * @interface SpaceTopicsInner
 */
export interface SpaceTopicsInner {
    /**
     * The description of the given topic.
     * @type {string}
     * @memberof SpaceTopicsInner
     */
    'description'?: string;
    /**
     * An ID suitable for use in the REST API.
     * @type {string}
     * @memberof SpaceTopicsInner
     */
    'id': string;
    /**
     * The name of the given topic.
     * @type {string}
     * @memberof SpaceTopicsInner
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface StreamingTweetResponse
 */
export interface StreamingTweetResponse {
    /**
     * 
     * @type {Tweet}
     * @memberof StreamingTweetResponse
     */
    'data'?: Tweet;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof StreamingTweetResponse
     */
    'errors'?: Array<Problem>;
    /**
     * 
     * @type {Expansions}
     * @memberof StreamingTweetResponse
     */
    'includes'?: Expansions;
}
/**
 * The topic of a Space, as selected by its creator.
 * @export
 * @interface Topic
 */
export interface Topic {
    /**
     * The description of the given topic.
     * @type {string}
     * @memberof Topic
     */
    'description'?: string;
    /**
     * Unique identifier of this Topic.
     * @type {string}
     * @memberof Topic
     */
    'id': string;
    /**
     * The name of the given topic.
     * @type {string}
     * @memberof Topic
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Tweet
 */
export interface Tweet {
    /**
     * 
     * @type {TweetAttachments}
     * @memberof Tweet
     */
    'attachments'?: TweetAttachments;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof Tweet
     */
    'author_id'?: string;
    /**
     * 
     * @type {Array<ContextAnnotation>}
     * @memberof Tweet
     */
    'context_annotations'?: Array<ContextAnnotation>;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof Tweet
     */
    'conversation_id'?: string;
    /**
     * Creation time of the Tweet.
     * @type {string}
     * @memberof Tweet
     */
    'created_at'?: string;
    /**
     * 
     * @type {TweetEditControls}
     * @memberof Tweet
     */
    'edit_controls'?: TweetEditControls;
    /**
     * A list of Tweet Ids in this Tweet chain.
     * @type {Array<string>}
     * @memberof Tweet
     */
    'edit_history_tweet_ids': Array<string>;
    /**
     * 
     * @type {FullTextEntities}
     * @memberof Tweet
     */
    'entities'?: FullTextEntities;
    /**
     * 
     * @type {TweetGeo}
     * @memberof Tweet
     */
    'geo'?: TweetGeo;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof Tweet
     */
    'id': string;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof Tweet
     */
    'in_reply_to_user_id'?: string;
    /**
     * Language of the Tweet, if detected by Twitter. Returned as a BCP47 language tag.
     * @type {string}
     * @memberof Tweet
     */
    'lang'?: string;
    /**
     * 
     * @type {TweetNonPublicMetrics}
     * @memberof Tweet
     */
    'non_public_metrics'?: TweetNonPublicMetrics;
    /**
     * 
     * @type {TweetOrganicMetrics}
     * @memberof Tweet
     */
    'organic_metrics'?: TweetOrganicMetrics;
    /**
     * Indicates if this Tweet contains URLs marked as sensitive, for example content suitable for mature audiences.
     * @type {boolean}
     * @memberof Tweet
     */
    'possibly_sensitive'?: boolean;
    /**
     * 
     * @type {TweetPromotedMetrics}
     * @memberof Tweet
     */
    'promoted_metrics'?: TweetPromotedMetrics;
    /**
     * 
     * @type {TweetPublicMetrics}
     * @memberof Tweet
     */
    'public_metrics'?: TweetPublicMetrics;
    /**
     * A list of Tweets this Tweet refers to. For example, if the parent Tweet is a Retweet, a Quoted Tweet or a Reply, it will include the related Tweet referenced to by its parent.
     * @type {Array<TweetReferencedTweetsInner>}
     * @memberof Tweet
     */
    'referenced_tweets'?: Array<TweetReferencedTweetsInner>;
    /**
     * 
     * @type {ReplySettings}
     * @memberof Tweet
     */
    'reply_settings'?: ReplySettings;
    /**
     * This is deprecated.
     * @type {string}
     * @memberof Tweet
     */
    'source'?: string;
    /**
     * The content of the Tweet.
     * @type {string}
     * @memberof Tweet
     */
    'text': string;
    /**
     * 
     * @type {TweetWithheld}
     * @memberof Tweet
     */
    'withheld'?: TweetWithheld;
}


/**
 * Specifies the type of attachments (if any) present in this Tweet.
 * @export
 * @interface TweetAttachments
 */
export interface TweetAttachments {
    /**
     * A list of Media Keys for each one of the media attachments (if media are attached).
     * @type {Array<string>}
     * @memberof TweetAttachments
     */
    'media_keys'?: Array<string>;
    /**
     * A list of poll IDs (if polls are attached).
     * @type {Array<string>}
     * @memberof TweetAttachments
     */
    'poll_ids'?: Array<string>;
}
/**
 * @type TweetComplianceData
 * Tweet compliance data.
 * @export
 */
export type TweetComplianceData = TweetDeleteComplianceSchema | TweetDropComplianceSchema | TweetEditComplianceSchema | TweetUndropComplianceSchema | TweetWithheldComplianceSchema;

/**
 * 
 * @export
 * @interface TweetComplianceSchema
 */
export interface TweetComplianceSchema {
    /**
     * Event time.
     * @type {string}
     * @memberof TweetComplianceSchema
     */
    'event_at': string;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof TweetComplianceSchema
     */
    'quote_tweet_id'?: string;
    /**
     * 
     * @type {TweetComplianceSchemaTweet}
     * @memberof TweetComplianceSchema
     */
    'tweet': TweetComplianceSchemaTweet;
}
/**
 * 
 * @export
 * @interface TweetComplianceSchemaTweet
 */
export interface TweetComplianceSchemaTweet {
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof TweetComplianceSchemaTweet
     */
    'author_id': string;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof TweetComplianceSchemaTweet
     */
    'id': string;
}
/**
 * @type TweetComplianceStreamResponse
 * Tweet compliance stream events.
 * @export
 */
export type TweetComplianceStreamResponse = TweetComplianceStreamResponseOneOf | TweetComplianceStreamResponseOneOf1;

/**
 * Compliance event.
 * @export
 * @interface TweetComplianceStreamResponseOneOf
 */
export interface TweetComplianceStreamResponseOneOf {
    /**
     * 
     * @type {TweetComplianceData}
     * @memberof TweetComplianceStreamResponseOneOf
     */
    'data': TweetComplianceData;
}
/**
 * 
 * @export
 * @interface TweetComplianceStreamResponseOneOf1
 */
export interface TweetComplianceStreamResponseOneOf1 {
    /**
     * 
     * @type {Array<Problem>}
     * @memberof TweetComplianceStreamResponseOneOf1
     */
    'errors': Array<Problem>;
}
/**
 * 
 * @export
 * @interface TweetCreateRequest
 */
export interface TweetCreateRequest {
    /**
     * Card Uri Parameter. This is mutually exclusive from Quote Tweet Id, Poll, Media, and Direct Message Deep Link.
     * @type {string}
     * @memberof TweetCreateRequest
     */
    'card_uri'?: string;
    /**
     * Link to take the conversation from the public timeline to a private Direct Message.
     * @type {string}
     * @memberof TweetCreateRequest
     */
    'direct_message_deep_link'?: string;
    /**
     * Exclusive Tweet for super followers.
     * @type {boolean}
     * @memberof TweetCreateRequest
     */
    'for_super_followers_only'?: boolean;
    /**
     * 
     * @type {TweetCreateRequestGeo}
     * @memberof TweetCreateRequest
     */
    'geo'?: TweetCreateRequestGeo;
    /**
     * 
     * @type {TweetCreateRequestMedia}
     * @memberof TweetCreateRequest
     */
    'media'?: TweetCreateRequestMedia;
    /**
     * Nullcasted (promoted-only) Tweets do not appear in the public timeline and are not served to followers.
     * @type {boolean}
     * @memberof TweetCreateRequest
     */
    'nullcast'?: boolean;
    /**
     * 
     * @type {TweetCreateRequestPoll}
     * @memberof TweetCreateRequest
     */
    'poll'?: TweetCreateRequestPoll;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof TweetCreateRequest
     */
    'quote_tweet_id'?: string;
    /**
     * 
     * @type {TweetCreateRequestReply}
     * @memberof TweetCreateRequest
     */
    'reply'?: TweetCreateRequestReply;
    /**
     * Settings to indicate who can reply to the Tweet.
     * @type {string}
     * @memberof TweetCreateRequest
     */
    'reply_settings'?: TweetCreateRequestReplySettingsEnum;
    /**
     * The content of the Tweet.
     * @type {string}
     * @memberof TweetCreateRequest
     */
    'text'?: string;
}

export const TweetCreateRequestReplySettingsEnum = {
    Following: 'following',
    MentionedUsers: 'mentionedUsers'
} as const;

export type TweetCreateRequestReplySettingsEnum = typeof TweetCreateRequestReplySettingsEnum[keyof typeof TweetCreateRequestReplySettingsEnum];

/**
 * Place ID being attached to the Tweet for geo location.
 * @export
 * @interface TweetCreateRequestGeo
 */
export interface TweetCreateRequestGeo {
    /**
     * 
     * @type {string}
     * @memberof TweetCreateRequestGeo
     */
    'place_id'?: string;
}
/**
 * Media information being attached to created Tweet. This is mutually exclusive from Quote Tweet Id, Poll, and Card URI.
 * @export
 * @interface TweetCreateRequestMedia
 */
export interface TweetCreateRequestMedia {
    /**
     * A list of Media Ids to be attached to a created Tweet.
     * @type {Array<string>}
     * @memberof TweetCreateRequestMedia
     */
    'media_ids': Array<string>;
    /**
     * A list of User Ids to be tagged in the media for created Tweet.
     * @type {Array<string>}
     * @memberof TweetCreateRequestMedia
     */
    'tagged_user_ids'?: Array<string>;
}
/**
 * Poll options for a Tweet with a poll. This is mutually exclusive from Media, Quote Tweet Id, and Card URI.
 * @export
 * @interface TweetCreateRequestPoll
 */
export interface TweetCreateRequestPoll {
    /**
     * Duration of the poll in minutes.
     * @type {number}
     * @memberof TweetCreateRequestPoll
     */
    'duration_minutes': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof TweetCreateRequestPoll
     */
    'options': Array<string>;
    /**
     * Settings to indicate who can reply to the Tweet.
     * @type {string}
     * @memberof TweetCreateRequestPoll
     */
    'reply_settings'?: TweetCreateRequestPollReplySettingsEnum;
}

export const TweetCreateRequestPollReplySettingsEnum = {
    Following: 'following',
    MentionedUsers: 'mentionedUsers'
} as const;

export type TweetCreateRequestPollReplySettingsEnum = typeof TweetCreateRequestPollReplySettingsEnum[keyof typeof TweetCreateRequestPollReplySettingsEnum];

/**
 * Tweet information of the Tweet being replied to.
 * @export
 * @interface TweetCreateRequestReply
 */
export interface TweetCreateRequestReply {
    /**
     * A list of User Ids to be excluded from the reply Tweet.
     * @type {Array<string>}
     * @memberof TweetCreateRequestReply
     */
    'exclude_reply_user_ids'?: Array<string>;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof TweetCreateRequestReply
     */
    'in_reply_to_tweet_id': string;
}
/**
 * 
 * @export
 * @interface TweetCreateResponse
 */
export interface TweetCreateResponse {
    /**
     * 
     * @type {TweetCreateResponseData}
     * @memberof TweetCreateResponse
     */
    'data'?: TweetCreateResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof TweetCreateResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface TweetCreateResponseData
 */
export interface TweetCreateResponseData {
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof TweetCreateResponseData
     */
    'id': string;
    /**
     * The content of the Tweet.
     * @type {string}
     * @memberof TweetCreateResponseData
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface TweetDeleteComplianceSchema
 */
export interface TweetDeleteComplianceSchema {
    /**
     * 
     * @type {TweetComplianceSchema}
     * @memberof TweetDeleteComplianceSchema
     */
    'delete': TweetComplianceSchema;
}
/**
 * 
 * @export
 * @interface TweetDeleteResponse
 */
export interface TweetDeleteResponse {
    /**
     * 
     * @type {TweetDeleteResponseData}
     * @memberof TweetDeleteResponse
     */
    'data'?: TweetDeleteResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof TweetDeleteResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface TweetDeleteResponseData
 */
export interface TweetDeleteResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof TweetDeleteResponseData
     */
    'deleted': boolean;
}
/**
 * 
 * @export
 * @interface TweetDropComplianceSchema
 */
export interface TweetDropComplianceSchema {
    /**
     * 
     * @type {TweetComplianceSchema}
     * @memberof TweetDropComplianceSchema
     */
    'drop': TweetComplianceSchema;
}
/**
 * 
 * @export
 * @interface TweetEditComplianceObjectSchema
 */
export interface TweetEditComplianceObjectSchema {
    /**
     * 
     * @type {Array<string>}
     * @memberof TweetEditComplianceObjectSchema
     */
    'edit_tweet_ids': Array<string>;
    /**
     * Event time.
     * @type {string}
     * @memberof TweetEditComplianceObjectSchema
     */
    'event_at': string;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof TweetEditComplianceObjectSchema
     */
    'initial_tweet_id': string;
    /**
     * 
     * @type {DmEventReferencedTweetsInner}
     * @memberof TweetEditComplianceObjectSchema
     */
    'tweet': DmEventReferencedTweetsInner;
}
/**
 * 
 * @export
 * @interface TweetEditComplianceSchema
 */
export interface TweetEditComplianceSchema {
    /**
     * 
     * @type {TweetEditComplianceObjectSchema}
     * @memberof TweetEditComplianceSchema
     */
    'tweet_edit': TweetEditComplianceObjectSchema;
}
/**
 * 
 * @export
 * @interface TweetEditControls
 */
export interface TweetEditControls {
    /**
     * Time when Tweet is no longer editable.
     * @type {string}
     * @memberof TweetEditControls
     */
    'editable_until': string;
    /**
     * Number of times this Tweet can be edited.
     * @type {number}
     * @memberof TweetEditControls
     */
    'edits_remaining': number;
    /**
     * Indicates if this Tweet is eligible to be edited.
     * @type {boolean}
     * @memberof TweetEditControls
     */
    'is_edit_eligible': boolean;
}
/**
 * The location tagged on the Tweet, if the user provided one.
 * @export
 * @interface TweetGeo
 */
export interface TweetGeo {
    /**
     * 
     * @type {Point}
     * @memberof TweetGeo
     */
    'coordinates'?: Point;
    /**
     * The identifier for this place.
     * @type {string}
     * @memberof TweetGeo
     */
    'place_id'?: string;
}
/**
 * 
 * @export
 * @interface TweetHideRequest
 */
export interface TweetHideRequest {
    /**
     * 
     * @type {boolean}
     * @memberof TweetHideRequest
     */
    'hidden': boolean;
}
/**
 * 
 * @export
 * @interface TweetHideResponse
 */
export interface TweetHideResponse {
    /**
     * 
     * @type {TweetHideResponseData}
     * @memberof TweetHideResponse
     */
    'data'?: TweetHideResponseData;
}
/**
 * 
 * @export
 * @interface TweetHideResponseData
 */
export interface TweetHideResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof TweetHideResponseData
     */
    'hidden'?: boolean;
}
/**
 * @type TweetLabelData
 * Tweet label data.
 * @export
 */
export type TweetLabelData = TweetNoticeSchema | TweetUnviewableSchema;

/**
 * @type TweetLabelStreamResponse
 * Tweet label stream events.
 * @export
 */
export type TweetLabelStreamResponse = TweetComplianceStreamResponseOneOf1 | TweetLabelStreamResponseOneOf;

/**
 * Tweet Label event.
 * @export
 * @interface TweetLabelStreamResponseOneOf
 */
export interface TweetLabelStreamResponseOneOf {
    /**
     * 
     * @type {TweetLabelData}
     * @memberof TweetLabelStreamResponseOneOf
     */
    'data': TweetLabelData;
}
/**
 * Nonpublic engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetNonPublicMetrics
 */
export interface TweetNonPublicMetrics {
    /**
     * Number of times this Tweet has been viewed.
     * @type {number}
     * @memberof TweetNonPublicMetrics
     */
    'impression_count'?: number;
}
/**
 * 
 * @export
 * @interface TweetNotice
 */
export interface TweetNotice {
    /**
     * If the label is being applied or removed. Possible values are ‘apply’ or ‘remove’.
     * @type {string}
     * @memberof TweetNotice
     */
    'application': string;
    /**
     * Information shown on the Tweet label
     * @type {string}
     * @memberof TweetNotice
     */
    'details'?: string;
    /**
     * Event time.
     * @type {string}
     * @memberof TweetNotice
     */
    'event_at': string;
    /**
     * The type of label on the Tweet
     * @type {string}
     * @memberof TweetNotice
     */
    'event_type': string;
    /**
     * Link to more information about this kind of label
     * @type {string}
     * @memberof TweetNotice
     */
    'extended_details_url'?: string;
    /**
     * Title/header of the Tweet label
     * @type {string}
     * @memberof TweetNotice
     */
    'label_title'?: string;
    /**
     * 
     * @type {TweetComplianceSchemaTweet}
     * @memberof TweetNotice
     */
    'tweet': TweetComplianceSchemaTweet;
}
/**
 * 
 * @export
 * @interface TweetNoticeSchema
 */
export interface TweetNoticeSchema {
    /**
     * 
     * @type {TweetNotice}
     * @memberof TweetNoticeSchema
     */
    'public_tweet_notice': TweetNotice;
}
/**
 * Organic nonpublic engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetOrganicMetrics
 */
export interface TweetOrganicMetrics {
    /**
     * Number of times this Tweet has been viewed.
     * @type {number}
     * @memberof TweetOrganicMetrics
     */
    'impression_count': number;
    /**
     * Number of times this Tweet has been liked.
     * @type {number}
     * @memberof TweetOrganicMetrics
     */
    'like_count': number;
    /**
     * Number of times this Tweet has been replied to.
     * @type {number}
     * @memberof TweetOrganicMetrics
     */
    'reply_count': number;
    /**
     * Number of times this Tweet has been Retweeted.
     * @type {number}
     * @memberof TweetOrganicMetrics
     */
    'retweet_count': number;
}
/**
 * Promoted nonpublic engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetPromotedMetrics
 */
export interface TweetPromotedMetrics {
    /**
     * Number of times this Tweet has been viewed.
     * @type {number}
     * @memberof TweetPromotedMetrics
     */
    'impression_count'?: number;
    /**
     * Number of times this Tweet has been liked.
     * @type {number}
     * @memberof TweetPromotedMetrics
     */
    'like_count'?: number;
    /**
     * Number of times this Tweet has been replied to.
     * @type {number}
     * @memberof TweetPromotedMetrics
     */
    'reply_count'?: number;
    /**
     * Number of times this Tweet has been Retweeted.
     * @type {number}
     * @memberof TweetPromotedMetrics
     */
    'retweet_count'?: number;
}
/**
 * Engagement metrics for the Tweet at the time of the request.
 * @export
 * @interface TweetPublicMetrics
 */
export interface TweetPublicMetrics {
    /**
     * Number of times this Tweet has been viewed.
     * @type {number}
     * @memberof TweetPublicMetrics
     */
    'impression_count': number;
    /**
     * Number of times this Tweet has been liked.
     * @type {number}
     * @memberof TweetPublicMetrics
     */
    'like_count': number;
    /**
     * Number of times this Tweet has been quoted.
     * @type {number}
     * @memberof TweetPublicMetrics
     */
    'quote_count'?: number;
    /**
     * Number of times this Tweet has been replied to.
     * @type {number}
     * @memberof TweetPublicMetrics
     */
    'reply_count': number;
    /**
     * Number of times this Tweet has been Retweeted.
     * @type {number}
     * @memberof TweetPublicMetrics
     */
    'retweet_count': number;
}
/**
 * 
 * @export
 * @interface TweetReferencedTweetsInner
 */
export interface TweetReferencedTweetsInner {
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof TweetReferencedTweetsInner
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof TweetReferencedTweetsInner
     */
    'type': TweetReferencedTweetsInnerTypeEnum;
}

export const TweetReferencedTweetsInnerTypeEnum = {
    Retweeted: 'retweeted',
    Quoted: 'quoted',
    RepliedTo: 'replied_to'
} as const;

export type TweetReferencedTweetsInnerTypeEnum = typeof TweetReferencedTweetsInnerTypeEnum[keyof typeof TweetReferencedTweetsInnerTypeEnum];

/**
 * 
 * @export
 * @interface TweetTakedownComplianceSchema
 */
export interface TweetTakedownComplianceSchema {
    /**
     * Event time.
     * @type {string}
     * @memberof TweetTakedownComplianceSchema
     */
    'event_at': string;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof TweetTakedownComplianceSchema
     */
    'quote_tweet_id'?: string;
    /**
     * 
     * @type {TweetComplianceSchemaTweet}
     * @memberof TweetTakedownComplianceSchema
     */
    'tweet': TweetComplianceSchemaTweet;
    /**
     * 
     * @type {Array<string>}
     * @memberof TweetTakedownComplianceSchema
     */
    'withheld_in_countries': Array<string>;
}
/**
 * 
 * @export
 * @interface TweetUndropComplianceSchema
 */
export interface TweetUndropComplianceSchema {
    /**
     * 
     * @type {TweetComplianceSchema}
     * @memberof TweetUndropComplianceSchema
     */
    'undrop': TweetComplianceSchema;
}
/**
 * 
 * @export
 * @interface TweetUnviewable
 */
export interface TweetUnviewable {
    /**
     * If the label is being applied or removed. Possible values are ‘apply’ or ‘remove’.
     * @type {string}
     * @memberof TweetUnviewable
     */
    'application': string;
    /**
     * Event time.
     * @type {string}
     * @memberof TweetUnviewable
     */
    'event_at': string;
    /**
     * 
     * @type {TweetComplianceSchemaTweet}
     * @memberof TweetUnviewable
     */
    'tweet': TweetComplianceSchemaTweet;
}
/**
 * 
 * @export
 * @interface TweetUnviewableSchema
 */
export interface TweetUnviewableSchema {
    /**
     * 
     * @type {TweetUnviewable}
     * @memberof TweetUnviewableSchema
     */
    'public_tweet_unviewable': TweetUnviewable;
}
/**
 * Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
 * @export
 * @interface TweetWithheld
 */
export interface TweetWithheld {
    /**
     * Indicates if the content is being withheld for on the basis of copyright infringement.
     * @type {boolean}
     * @memberof TweetWithheld
     */
    'copyright': boolean;
    /**
     * Provides a list of countries where this content is not available.
     * @type {Set<string>}
     * @memberof TweetWithheld
     */
    'country_codes': Set<string>;
    /**
     * Indicates whether the content being withheld is the `tweet` or a `user`.
     * @type {string}
     * @memberof TweetWithheld
     */
    'scope'?: TweetWithheldScopeEnum;
}

export const TweetWithheldScopeEnum = {
    Tweet: 'tweet',
    User: 'user'
} as const;

export type TweetWithheldScopeEnum = typeof TweetWithheldScopeEnum[keyof typeof TweetWithheldScopeEnum];

/**
 * 
 * @export
 * @interface TweetWithheldComplianceSchema
 */
export interface TweetWithheldComplianceSchema {
    /**
     * 
     * @type {TweetTakedownComplianceSchema}
     * @memberof TweetWithheldComplianceSchema
     */
    'withheld': TweetTakedownComplianceSchema;
}
/**
 * A problem that indicates that the authentication used is not supported.
 * @export
 * @interface UnsupportedAuthenticationProblem
 */
export interface UnsupportedAuthenticationProblem extends Problem {
}
/**
 * Represent the portion of text recognized as a URL, and its start and end position within the text.
 * @export
 * @interface UrlEntity
 */
export interface UrlEntity {
    /**
     * Index (zero-based) at which position this entity ends.  The index is exclusive.
     * @type {number}
     * @memberof UrlEntity
     */
    'end': number;
    /**
     * Index (zero-based) at which position this entity starts.  The index is inclusive.
     * @type {number}
     * @memberof UrlEntity
     */
    'start': number;
    /**
     * Description of the URL landing page.
     * @type {string}
     * @memberof UrlEntity
     */
    'description'?: string;
    /**
     * The URL as displayed in the Twitter client.
     * @type {string}
     * @memberof UrlEntity
     */
    'display_url'?: string;
    /**
     * A validly formatted URL.
     * @type {string}
     * @memberof UrlEntity
     */
    'expanded_url'?: string;
    /**
     * 
     * @type {Array<UrlImage>}
     * @memberof UrlEntity
     */
    'images'?: Array<UrlImage>;
    /**
     * The Media Key identifier for this attachment.
     * @type {string}
     * @memberof UrlEntity
     */
    'media_key'?: string;
    /**
     * HTTP Status Code.
     * @type {number}
     * @memberof UrlEntity
     */
    'status'?: number;
    /**
     * Title of the page the URL points to.
     * @type {string}
     * @memberof UrlEntity
     */
    'title'?: string;
    /**
     * Fully resolved url.
     * @type {string}
     * @memberof UrlEntity
     */
    'unwound_url'?: string;
    /**
     * A validly formatted URL.
     * @type {string}
     * @memberof UrlEntity
     */
    'url': string;
}
/**
 * Represent the portion of text recognized as a URL.
 * @export
 * @interface UrlFields
 */
export interface UrlFields {
    /**
     * Description of the URL landing page.
     * @type {string}
     * @memberof UrlFields
     */
    'description'?: string;
    /**
     * The URL as displayed in the Twitter client.
     * @type {string}
     * @memberof UrlFields
     */
    'display_url'?: string;
    /**
     * A validly formatted URL.
     * @type {string}
     * @memberof UrlFields
     */
    'expanded_url'?: string;
    /**
     * 
     * @type {Array<UrlImage>}
     * @memberof UrlFields
     */
    'images'?: Array<UrlImage>;
    /**
     * The Media Key identifier for this attachment.
     * @type {string}
     * @memberof UrlFields
     */
    'media_key'?: string;
    /**
     * HTTP Status Code.
     * @type {number}
     * @memberof UrlFields
     */
    'status'?: number;
    /**
     * Title of the page the URL points to.
     * @type {string}
     * @memberof UrlFields
     */
    'title'?: string;
    /**
     * Fully resolved url.
     * @type {string}
     * @memberof UrlFields
     */
    'unwound_url'?: string;
    /**
     * A validly formatted URL.
     * @type {string}
     * @memberof UrlFields
     */
    'url': string;
}
/**
 * Represent the information for the URL image.
 * @export
 * @interface UrlImage
 */
export interface UrlImage {
    /**
     * The height of the media in pixels.
     * @type {number}
     * @memberof UrlImage
     */
    'height'?: number;
    /**
     * A validly formatted URL.
     * @type {string}
     * @memberof UrlImage
     */
    'url'?: string;
    /**
     * The width of the media in pixels.
     * @type {number}
     * @memberof UrlImage
     */
    'width'?: number;
}
/**
 * A problem that indicates that a usage cap has been exceeded.
 * @export
 * @interface UsageCapExceededProblem
 */
export interface UsageCapExceededProblem extends Problem {
    /**
     * 
     * @type {string}
     * @memberof UsageCapExceededProblem
     */
    'period'?: UsageCapExceededProblemPeriodEnum;
    /**
     * 
     * @type {string}
     * @memberof UsageCapExceededProblem
     */
    'scope'?: UsageCapExceededProblemScopeEnum;
}

export const UsageCapExceededProblemPeriodEnum = {
    Daily: 'Daily',
    Monthly: 'Monthly'
} as const;

export type UsageCapExceededProblemPeriodEnum = typeof UsageCapExceededProblemPeriodEnum[keyof typeof UsageCapExceededProblemPeriodEnum];
export const UsageCapExceededProblemScopeEnum = {
    Account: 'Account',
    Product: 'Product'
} as const;

export type UsageCapExceededProblemScopeEnum = typeof UsageCapExceededProblemScopeEnum[keyof typeof UsageCapExceededProblemScopeEnum];

/**
 * 
 * @export
 * @interface UsageCapExceededProblemAllOf
 */
export interface UsageCapExceededProblemAllOf {
    /**
     * 
     * @type {string}
     * @memberof UsageCapExceededProblemAllOf
     */
    'period'?: UsageCapExceededProblemAllOfPeriodEnum;
    /**
     * 
     * @type {string}
     * @memberof UsageCapExceededProblemAllOf
     */
    'scope'?: UsageCapExceededProblemAllOfScopeEnum;
}

export const UsageCapExceededProblemAllOfPeriodEnum = {
    Daily: 'Daily',
    Monthly: 'Monthly'
} as const;

export type UsageCapExceededProblemAllOfPeriodEnum = typeof UsageCapExceededProblemAllOfPeriodEnum[keyof typeof UsageCapExceededProblemAllOfPeriodEnum];
export const UsageCapExceededProblemAllOfScopeEnum = {
    Account: 'Account',
    Product: 'Product'
} as const;

export type UsageCapExceededProblemAllOfScopeEnum = typeof UsageCapExceededProblemAllOfScopeEnum[keyof typeof UsageCapExceededProblemAllOfScopeEnum];

/**
 * The Twitter User object.
 * @export
 * @interface User
 */
export interface User {
    /**
     * Creation time of this User.
     * @type {string}
     * @memberof User
     */
    'created_at'?: string;
    /**
     * The text of this User\'s profile description (also known as bio), if the User provided one.
     * @type {string}
     * @memberof User
     */
    'description'?: string;
    /**
     * 
     * @type {UserEntities}
     * @memberof User
     */
    'entities'?: UserEntities;
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * The location specified in the User\'s profile, if the User provided one. As this is a freeform value, it may not indicate a valid location, but it may be fuzzily evaluated when performing searches with location queries.
     * @type {string}
     * @memberof User
     */
    'location'?: string;
    /**
     * The friendly name of this User, as shown on their profile.
     * @type {string}
     * @memberof User
     */
    'name': string;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof User
     */
    'pinned_tweet_id'?: string;
    /**
     * The URL to the profile image for this User.
     * @type {string}
     * @memberof User
     */
    'profile_image_url'?: string;
    /**
     * Indicates if this User has chosen to protect their Tweets (in other words, if this User\'s Tweets are private).
     * @type {boolean}
     * @memberof User
     */
    'protected'?: boolean;
    /**
     * 
     * @type {UserPublicMetrics}
     * @memberof User
     */
    'public_metrics'?: UserPublicMetrics;
    /**
     * The URL specified in the User\'s profile.
     * @type {string}
     * @memberof User
     */
    'url'?: string;
    /**
     * The Twitter handle (screen name) of this user.
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * Indicate if this User is a verified Twitter User.
     * @type {boolean}
     * @memberof User
     */
    'verified'?: boolean;
    /**
     * The Twitter Blue verified type of the user, eg: blue, government, business or none.
     * @type {string}
     * @memberof User
     */
    'verified_type'?: string;
    /**
     * 
     * @type {UserWithheld}
     * @memberof User
     */
    'withheld'?: UserWithheld;
}
/**
 * @type UserComplianceData
 * User compliance data.
 * @export
 */
export type UserComplianceData = UserDeleteComplianceSchema | UserProfileModificationComplianceSchema | UserProtectComplianceSchema | UserScrubGeoSchema | UserSuspendComplianceSchema | UserUndeleteComplianceSchema | UserUnprotectComplianceSchema | UserUnsuspendComplianceSchema | UserWithheldComplianceSchema;

/**
 * 
 * @export
 * @interface UserComplianceSchema
 */
export interface UserComplianceSchema {
    /**
     * Event time.
     * @type {string}
     * @memberof UserComplianceSchema
     */
    'event_at': string;
    /**
     * 
     * @type {UserComplianceSchemaUser}
     * @memberof UserComplianceSchema
     */
    'user': UserComplianceSchemaUser;
}
/**
 * 
 * @export
 * @interface UserComplianceSchemaUser
 */
export interface UserComplianceSchemaUser {
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof UserComplianceSchemaUser
     */
    'id': string;
}
/**
 * @type UserComplianceStreamResponse
 * User compliance stream events.
 * @export
 */
export type UserComplianceStreamResponse = TweetComplianceStreamResponseOneOf1 | UserComplianceStreamResponseOneOf;

/**
 * User compliance event.
 * @export
 * @interface UserComplianceStreamResponseOneOf
 */
export interface UserComplianceStreamResponseOneOf {
    /**
     * 
     * @type {UserComplianceData}
     * @memberof UserComplianceStreamResponseOneOf
     */
    'data': UserComplianceData;
}
/**
 * 
 * @export
 * @interface UserDeleteComplianceSchema
 */
export interface UserDeleteComplianceSchema {
    /**
     * 
     * @type {UserComplianceSchema}
     * @memberof UserDeleteComplianceSchema
     */
    'user_delete': UserComplianceSchema;
}
/**
 * A list of metadata found in the User\'s profile description.
 * @export
 * @interface UserEntities
 */
export interface UserEntities {
    /**
     * 
     * @type {FullTextEntities}
     * @memberof UserEntities
     */
    'description'?: FullTextEntities;
    /**
     * 
     * @type {UserEntitiesUrl}
     * @memberof UserEntities
     */
    'url'?: UserEntitiesUrl;
}
/**
 * Expanded details for the URL specified in the User\'s profile, with start and end indices.
 * @export
 * @interface UserEntitiesUrl
 */
export interface UserEntitiesUrl {
    /**
     * 
     * @type {Array<UrlEntity>}
     * @memberof UserEntitiesUrl
     */
    'urls'?: Array<UrlEntity>;
}
/**
 * 
 * @export
 * @interface UserProfileModificationComplianceSchema
 */
export interface UserProfileModificationComplianceSchema {
    /**
     * 
     * @type {UserProfileModificationObjectSchema}
     * @memberof UserProfileModificationComplianceSchema
     */
    'user_profile_modification': UserProfileModificationObjectSchema;
}
/**
 * 
 * @export
 * @interface UserProfileModificationObjectSchema
 */
export interface UserProfileModificationObjectSchema {
    /**
     * Event time.
     * @type {string}
     * @memberof UserProfileModificationObjectSchema
     */
    'event_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileModificationObjectSchema
     */
    'new_value': string;
    /**
     * 
     * @type {string}
     * @memberof UserProfileModificationObjectSchema
     */
    'profile_field': string;
    /**
     * 
     * @type {UserComplianceSchemaUser}
     * @memberof UserProfileModificationObjectSchema
     */
    'user': UserComplianceSchemaUser;
}
/**
 * 
 * @export
 * @interface UserProtectComplianceSchema
 */
export interface UserProtectComplianceSchema {
    /**
     * 
     * @type {UserComplianceSchema}
     * @memberof UserProtectComplianceSchema
     */
    'user_protect': UserComplianceSchema;
}
/**
 * A list of metrics for this User.
 * @export
 * @interface UserPublicMetrics
 */
export interface UserPublicMetrics {
    /**
     * Number of Users who are following this User.
     * @type {number}
     * @memberof UserPublicMetrics
     */
    'followers_count': number;
    /**
     * Number of Users this User is following.
     * @type {number}
     * @memberof UserPublicMetrics
     */
    'following_count': number;
    /**
     * The number of lists that include this User.
     * @type {number}
     * @memberof UserPublicMetrics
     */
    'listed_count': number;
    /**
     * The number of Tweets (including Retweets) posted by this User.
     * @type {number}
     * @memberof UserPublicMetrics
     */
    'tweet_count': number;
}
/**
 * 
 * @export
 * @interface UserScrubGeoObjectSchema
 */
export interface UserScrubGeoObjectSchema {
    /**
     * Event time.
     * @type {string}
     * @memberof UserScrubGeoObjectSchema
     */
    'event_at': string;
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof UserScrubGeoObjectSchema
     */
    'up_to_tweet_id': string;
    /**
     * 
     * @type {UserComplianceSchemaUser}
     * @memberof UserScrubGeoObjectSchema
     */
    'user': UserComplianceSchemaUser;
}
/**
 * 
 * @export
 * @interface UserScrubGeoSchema
 */
export interface UserScrubGeoSchema {
    /**
     * 
     * @type {UserScrubGeoObjectSchema}
     * @memberof UserScrubGeoSchema
     */
    'scrub_geo': UserScrubGeoObjectSchema;
}
/**
 * 
 * @export
 * @interface UserSuspendComplianceSchema
 */
export interface UserSuspendComplianceSchema {
    /**
     * 
     * @type {UserComplianceSchema}
     * @memberof UserSuspendComplianceSchema
     */
    'user_suspend': UserComplianceSchema;
}
/**
 * 
 * @export
 * @interface UserTakedownComplianceSchema
 */
export interface UserTakedownComplianceSchema {
    /**
     * Event time.
     * @type {string}
     * @memberof UserTakedownComplianceSchema
     */
    'event_at': string;
    /**
     * 
     * @type {UserComplianceSchemaUser}
     * @memberof UserTakedownComplianceSchema
     */
    'user': UserComplianceSchemaUser;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserTakedownComplianceSchema
     */
    'withheld_in_countries': Array<string>;
}
/**
 * 
 * @export
 * @interface UserUndeleteComplianceSchema
 */
export interface UserUndeleteComplianceSchema {
    /**
     * 
     * @type {UserComplianceSchema}
     * @memberof UserUndeleteComplianceSchema
     */
    'user_undelete': UserComplianceSchema;
}
/**
 * 
 * @export
 * @interface UserUnprotectComplianceSchema
 */
export interface UserUnprotectComplianceSchema {
    /**
     * 
     * @type {UserComplianceSchema}
     * @memberof UserUnprotectComplianceSchema
     */
    'user_unprotect': UserComplianceSchema;
}
/**
 * 
 * @export
 * @interface UserUnsuspendComplianceSchema
 */
export interface UserUnsuspendComplianceSchema {
    /**
     * 
     * @type {UserComplianceSchema}
     * @memberof UserUnsuspendComplianceSchema
     */
    'user_unsuspend': UserComplianceSchema;
}
/**
 * Indicates withholding details for [withheld content](https://help.twitter.com/en/rules-and-policies/tweet-withheld-by-country).
 * @export
 * @interface UserWithheld
 */
export interface UserWithheld {
    /**
     * Provides a list of countries where this content is not available.
     * @type {Set<string>}
     * @memberof UserWithheld
     */
    'country_codes': Set<string>;
    /**
     * Indicates that the content being withheld is a `user`.
     * @type {string}
     * @memberof UserWithheld
     */
    'scope'?: UserWithheldScopeEnum;
}

export const UserWithheldScopeEnum = {
    User: 'user'
} as const;

export type UserWithheldScopeEnum = typeof UserWithheldScopeEnum[keyof typeof UserWithheldScopeEnum];

/**
 * 
 * @export
 * @interface UserWithheldComplianceSchema
 */
export interface UserWithheldComplianceSchema {
    /**
     * 
     * @type {UserTakedownComplianceSchema}
     * @memberof UserWithheldComplianceSchema
     */
    'user_withheld': UserTakedownComplianceSchema;
}
/**
 * 
 * @export
 * @interface UsersFollowingCreateRequest
 */
export interface UsersFollowingCreateRequest {
    /**
     * Unique identifier of this User. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof UsersFollowingCreateRequest
     */
    'target_user_id': string;
}
/**
 * 
 * @export
 * @interface UsersFollowingCreateResponse
 */
export interface UsersFollowingCreateResponse {
    /**
     * 
     * @type {UsersFollowingCreateResponseData}
     * @memberof UsersFollowingCreateResponse
     */
    'data'?: UsersFollowingCreateResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof UsersFollowingCreateResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface UsersFollowingCreateResponseData
 */
export interface UsersFollowingCreateResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof UsersFollowingCreateResponseData
     */
    'following'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UsersFollowingCreateResponseData
     */
    'pending_follow'?: boolean;
}
/**
 * 
 * @export
 * @interface UsersFollowingDeleteResponse
 */
export interface UsersFollowingDeleteResponse {
    /**
     * 
     * @type {ListFollowedResponseData}
     * @memberof UsersFollowingDeleteResponse
     */
    'data'?: ListFollowedResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof UsersFollowingDeleteResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface UsersLikesCreateRequest
 */
export interface UsersLikesCreateRequest {
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof UsersLikesCreateRequest
     */
    'tweet_id': string;
}
/**
 * 
 * @export
 * @interface UsersLikesCreateResponse
 */
export interface UsersLikesCreateResponse {
    /**
     * 
     * @type {UsersLikesCreateResponseData}
     * @memberof UsersLikesCreateResponse
     */
    'data'?: UsersLikesCreateResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof UsersLikesCreateResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface UsersLikesCreateResponseData
 */
export interface UsersLikesCreateResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof UsersLikesCreateResponseData
     */
    'liked'?: boolean;
}
/**
 * 
 * @export
 * @interface UsersLikesDeleteResponse
 */
export interface UsersLikesDeleteResponse {
    /**
     * 
     * @type {UsersLikesCreateResponseData}
     * @memberof UsersLikesDeleteResponse
     */
    'data'?: UsersLikesCreateResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof UsersLikesDeleteResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface UsersRetweetsCreateRequest
 */
export interface UsersRetweetsCreateRequest {
    /**
     * Unique identifier of this Tweet. This is returned as a string in order to avoid complications with languages and tools that cannot handle large integers.
     * @type {string}
     * @memberof UsersRetweetsCreateRequest
     */
    'tweet_id': string;
}
/**
 * 
 * @export
 * @interface UsersRetweetsCreateResponse
 */
export interface UsersRetweetsCreateResponse {
    /**
     * 
     * @type {UsersRetweetsCreateResponseData}
     * @memberof UsersRetweetsCreateResponse
     */
    'data'?: UsersRetweetsCreateResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof UsersRetweetsCreateResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface UsersRetweetsCreateResponseData
 */
export interface UsersRetweetsCreateResponseData {
    /**
     * 
     * @type {boolean}
     * @memberof UsersRetweetsCreateResponseData
     */
    'retweeted'?: boolean;
}
/**
 * 
 * @export
 * @interface UsersRetweetsDeleteResponse
 */
export interface UsersRetweetsDeleteResponse {
    /**
     * 
     * @type {UsersRetweetsCreateResponseData}
     * @memberof UsersRetweetsDeleteResponse
     */
    'data'?: UsersRetweetsCreateResponseData;
    /**
     * 
     * @type {Array<Problem>}
     * @memberof UsersRetweetsDeleteResponse
     */
    'errors'?: Array<Problem>;
}
/**
 * 
 * @export
 * @interface Variant
 */
export interface Variant {
    /**
     * The bit rate of the media.
     * @type {number}
     * @memberof Variant
     */
    'bit_rate'?: number;
    /**
     * The content type of the media.
     * @type {string}
     * @memberof Variant
     */
    'content_type'?: string;
    /**
     * The url to the media.
     * @type {string}
     * @memberof Variant
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface Video
 */
export interface Video extends Media {
    /**
     * 
     * @type {number}
     * @memberof Video
     */
    'duration_ms'?: number;
    /**
     * 
     * @type {VideoAllOfNonPublicMetrics}
     * @memberof Video
     */
    'non_public_metrics'?: VideoAllOfNonPublicMetrics;
    /**
     * 
     * @type {VideoAllOfOrganicMetrics}
     * @memberof Video
     */
    'organic_metrics'?: VideoAllOfOrganicMetrics;
    /**
     * 
     * @type {string}
     * @memberof Video
     */
    'preview_image_url'?: string;
    /**
     * 
     * @type {VideoAllOfPromotedMetrics}
     * @memberof Video
     */
    'promoted_metrics'?: VideoAllOfPromotedMetrics;
    /**
     * 
     * @type {VideoAllOfPublicMetrics}
     * @memberof Video
     */
    'public_metrics'?: VideoAllOfPublicMetrics;
    /**
     * An array of all available variants of the media.
     * @type {Array<Variant>}
     * @memberof Video
     */
    'variants'?: Array<Variant>;
}
/**
 * 
 * @export
 * @interface VideoAllOf
 */
export interface VideoAllOf {
    /**
     * 
     * @type {number}
     * @memberof VideoAllOf
     */
    'duration_ms'?: number;
    /**
     * 
     * @type {VideoAllOfNonPublicMetrics}
     * @memberof VideoAllOf
     */
    'non_public_metrics'?: VideoAllOfNonPublicMetrics;
    /**
     * 
     * @type {VideoAllOfOrganicMetrics}
     * @memberof VideoAllOf
     */
    'organic_metrics'?: VideoAllOfOrganicMetrics;
    /**
     * 
     * @type {string}
     * @memberof VideoAllOf
     */
    'preview_image_url'?: string;
    /**
     * 
     * @type {VideoAllOfPromotedMetrics}
     * @memberof VideoAllOf
     */
    'promoted_metrics'?: VideoAllOfPromotedMetrics;
    /**
     * 
     * @type {VideoAllOfPublicMetrics}
     * @memberof VideoAllOf
     */
    'public_metrics'?: VideoAllOfPublicMetrics;
    /**
     * An array of all available variants of the media.
     * @type {Array<Variant>}
     * @memberof VideoAllOf
     */
    'variants'?: Array<Variant>;
}
/**
 * Nonpublic engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfNonPublicMetrics
 */
export interface VideoAllOfNonPublicMetrics {
    /**
     * Number of users who made it through 0% of the video.
     * @type {number}
     * @memberof VideoAllOfNonPublicMetrics
     */
    'playback_0_count'?: number;
    /**
     * Number of users who made it through 100% of the video.
     * @type {number}
     * @memberof VideoAllOfNonPublicMetrics
     */
    'playback_100_count'?: number;
    /**
     * Number of users who made it through 25% of the video.
     * @type {number}
     * @memberof VideoAllOfNonPublicMetrics
     */
    'playback_25_count'?: number;
    /**
     * Number of users who made it through 50% of the video.
     * @type {number}
     * @memberof VideoAllOfNonPublicMetrics
     */
    'playback_50_count'?: number;
    /**
     * Number of users who made it through 75% of the video.
     * @type {number}
     * @memberof VideoAllOfNonPublicMetrics
     */
    'playback_75_count'?: number;
}
/**
 * Organic nonpublic engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfOrganicMetrics
 */
export interface VideoAllOfOrganicMetrics {
    /**
     * Number of users who made it through 0% of the video.
     * @type {number}
     * @memberof VideoAllOfOrganicMetrics
     */
    'playback_0_count'?: number;
    /**
     * Number of users who made it through 100% of the video.
     * @type {number}
     * @memberof VideoAllOfOrganicMetrics
     */
    'playback_100_count'?: number;
    /**
     * Number of users who made it through 25% of the video.
     * @type {number}
     * @memberof VideoAllOfOrganicMetrics
     */
    'playback_25_count'?: number;
    /**
     * Number of users who made it through 50% of the video.
     * @type {number}
     * @memberof VideoAllOfOrganicMetrics
     */
    'playback_50_count'?: number;
    /**
     * Number of users who made it through 75% of the video.
     * @type {number}
     * @memberof VideoAllOfOrganicMetrics
     */
    'playback_75_count'?: number;
    /**
     * Number of times this video has been viewed.
     * @type {number}
     * @memberof VideoAllOfOrganicMetrics
     */
    'view_count'?: number;
}
/**
 * Promoted nonpublic engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfPromotedMetrics
 */
export interface VideoAllOfPromotedMetrics {
    /**
     * Number of users who made it through 0% of the video.
     * @type {number}
     * @memberof VideoAllOfPromotedMetrics
     */
    'playback_0_count'?: number;
    /**
     * Number of users who made it through 100% of the video.
     * @type {number}
     * @memberof VideoAllOfPromotedMetrics
     */
    'playback_100_count'?: number;
    /**
     * Number of users who made it through 25% of the video.
     * @type {number}
     * @memberof VideoAllOfPromotedMetrics
     */
    'playback_25_count'?: number;
    /**
     * Number of users who made it through 50% of the video.
     * @type {number}
     * @memberof VideoAllOfPromotedMetrics
     */
    'playback_50_count'?: number;
    /**
     * Number of users who made it through 75% of the video.
     * @type {number}
     * @memberof VideoAllOfPromotedMetrics
     */
    'playback_75_count'?: number;
    /**
     * Number of times this video has been viewed.
     * @type {number}
     * @memberof VideoAllOfPromotedMetrics
     */
    'view_count'?: number;
}
/**
 * Engagement metrics for the Media at the time of the request.
 * @export
 * @interface VideoAllOfPublicMetrics
 */
export interface VideoAllOfPublicMetrics {
    /**
     * Number of times this video has been viewed.
     * @type {number}
     * @memberof VideoAllOfPublicMetrics
     */
    'view_count'?: number;
}

/**
 * BookmarksApi - axios parameter creator
 * @export
 */
export const BookmarksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns Tweet objects that have been bookmarked by the requesting User
         * @summary Bookmarks by User
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersIdBookmarks: async (id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUsersIdBookmarks', 'id', id)
            const localVarPath = `/2/users/{id}/bookmarks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["bookmark.read", "tweet.read", "users.read"], configuration)

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a Tweet (ID in the body) to the requesting User\'s (in the path) bookmarks
         * @summary Add Tweet to Bookmarks
         * @param {string} id The ID of the authenticated source User for whom to add bookmarks.
         * @param {BookmarkAddRequest} bookmarkAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersIdBookmarks: async (id: string, bookmarkAddRequest: BookmarkAddRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('postUsersIdBookmarks', 'id', id)
            // verify required parameter 'bookmarkAddRequest' is not null or undefined
            assertParamExists('postUsersIdBookmarks', 'bookmarkAddRequest', bookmarkAddRequest)
            const localVarPath = `/2/users/{id}/bookmarks`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["bookmark.write", "tweet.read", "users.read"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookmarkAddRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Tweet from the requesting User\'s bookmarked Tweets.
         * @summary Remove a bookmarked Tweet
         * @param {string} id The ID of the authenticated source User whose bookmark is to be removed.
         * @param {string} tweetId The ID of the Tweet that the source User is removing from bookmarks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBookmarksDelete: async (id: string, tweetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdBookmarksDelete', 'id', id)
            // verify required parameter 'tweetId' is not null or undefined
            assertParamExists('usersIdBookmarksDelete', 'tweetId', tweetId)
            const localVarPath = `/2/users/{id}/bookmarks/{tweet_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"tweet_id"}}`, encodeURIComponent(String(tweetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["bookmark.write", "tweet.read", "users.read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookmarksApi - functional programming interface
 * @export
 */
export const BookmarksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookmarksApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns Tweet objects that have been bookmarked by the requesting User
         * @summary Bookmarks by User
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersIdBookmarks(id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdBookmarksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersIdBookmarks(id, maxResults, paginationToken, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a Tweet (ID in the body) to the requesting User\'s (in the path) bookmarks
         * @summary Add Tweet to Bookmarks
         * @param {string} id The ID of the authenticated source User for whom to add bookmarks.
         * @param {BookmarkAddRequest} bookmarkAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postUsersIdBookmarks(id: string, bookmarkAddRequest: BookmarkAddRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postUsersIdBookmarks(id, bookmarkAddRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Tweet from the requesting User\'s bookmarked Tweets.
         * @summary Remove a bookmarked Tweet
         * @param {string} id The ID of the authenticated source User whose bookmark is to be removed.
         * @param {string} tweetId The ID of the Tweet that the source User is removing from bookmarks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdBookmarksDelete(id: string, tweetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdBookmarksDelete(id, tweetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BookmarksApi - factory interface
 * @export
 */
export const BookmarksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookmarksApiFp(configuration)
    return {
        /**
         * Returns Tweet objects that have been bookmarked by the requesting User
         * @summary Bookmarks by User
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersIdBookmarks(id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2UsersIdBookmarksResponse> {
            return localVarFp.getUsersIdBookmarks(id, maxResults, paginationToken, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a Tweet (ID in the body) to the requesting User\'s (in the path) bookmarks
         * @summary Add Tweet to Bookmarks
         * @param {string} id The ID of the authenticated source User for whom to add bookmarks.
         * @param {BookmarkAddRequest} bookmarkAddRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postUsersIdBookmarks(id: string, bookmarkAddRequest: BookmarkAddRequest, options?: any): AxiosPromise<BookmarkMutationResponse> {
            return localVarFp.postUsersIdBookmarks(id, bookmarkAddRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Tweet from the requesting User\'s bookmarked Tweets.
         * @summary Remove a bookmarked Tweet
         * @param {string} id The ID of the authenticated source User whose bookmark is to be removed.
         * @param {string} tweetId The ID of the Tweet that the source User is removing from bookmarks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBookmarksDelete(id: string, tweetId: string, options?: any): AxiosPromise<BookmarkMutationResponse> {
            return localVarFp.usersIdBookmarksDelete(id, tweetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookmarksApi - object-oriented interface
 * @export
 * @class BookmarksApi
 * @extends {BaseAPI}
 */
export class BookmarksApi extends BaseAPI {
    /**
     * Returns Tweet objects that have been bookmarked by the requesting User
     * @summary Bookmarks by User
     * @param {string} id The ID of the authenticated source User for whom to return results.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarksApi
     */
    public getUsersIdBookmarks(id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return BookmarksApiFp(this.configuration).getUsersIdBookmarks(id, maxResults, paginationToken, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a Tweet (ID in the body) to the requesting User\'s (in the path) bookmarks
     * @summary Add Tweet to Bookmarks
     * @param {string} id The ID of the authenticated source User for whom to add bookmarks.
     * @param {BookmarkAddRequest} bookmarkAddRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarksApi
     */
    public postUsersIdBookmarks(id: string, bookmarkAddRequest: BookmarkAddRequest, options?: AxiosRequestConfig) {
        return BookmarksApiFp(this.configuration).postUsersIdBookmarks(id, bookmarkAddRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Tweet from the requesting User\'s bookmarked Tweets.
     * @summary Remove a bookmarked Tweet
     * @param {string} id The ID of the authenticated source User whose bookmark is to be removed.
     * @param {string} tweetId The ID of the Tweet that the source User is removing from bookmarks.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookmarksApi
     */
    public usersIdBookmarksDelete(id: string, tweetId: string, options?: AxiosRequestConfig) {
        return BookmarksApiFp(this.configuration).usersIdBookmarksDelete(id, tweetId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ComplianceApi - axios parameter creator
 * @export
 */
export const ComplianceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a compliance for the given job type
         * @summary Create compliance job
         * @param {CreateComplianceJobRequest} createComplianceJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchComplianceJob: async (createComplianceJobRequest: CreateComplianceJobRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createComplianceJobRequest' is not null or undefined
            assertParamExists('createBatchComplianceJob', 'createComplianceJobRequest', createComplianceJobRequest)
            const localVarPath = `/2/compliance/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createComplianceJobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single Compliance Job by ID
         * @summary Get Compliance Job
         * @param {string} id The ID of the Compliance Job to retrieve.
         * @param {Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>} [complianceJobFields] A comma separated list of ComplianceJob fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchComplianceJob: async (id: string, complianceJobFields?: Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getBatchComplianceJob', 'id', id)
            const localVarPath = `/2/compliance/jobs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (complianceJobFields) {
                localVarQueryParameter['compliance_job.fields'] = Array.from(complianceJobFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams 100% of compliance data for Tweets
         * @summary Tweets Compliance stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweet Compliance events will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweet Compliance events will be provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweetsComplianceStream: async (partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partition' is not null or undefined
            assertParamExists('getTweetsComplianceStream', 'partition', partition)
            const localVarPath = `/2/tweets/compliance/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (backfillMinutes !== undefined) {
                localVarQueryParameter['backfill_minutes'] = backfillMinutes;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams 100% of labeling events applied to Tweets
         * @summary Tweets Label stream
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweet labels will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the Tweet labels will be provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweetsLabelStream: async (backfillMinutes?: number, startTime?: string, endTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/tweets/label/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (backfillMinutes !== undefined) {
                localVarQueryParameter['backfill_minutes'] = backfillMinutes;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams 100% of compliance data for Users
         * @summary Users Compliance stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the User Compliance events will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the User Compliance events will be provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersComplianceStream: async (partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partition' is not null or undefined
            assertParamExists('getUsersComplianceStream', 'partition', partition)
            const localVarPath = `/2/users/compliance/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (backfillMinutes !== undefined) {
                localVarQueryParameter['backfill_minutes'] = backfillMinutes;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns recent Compliance Jobs for a given job type and optional job status
         * @summary List Compliance Jobs
         * @param {'tweets' | 'users'} type Type of Compliance Job to list.
         * @param {'created' | 'in_progress' | 'failed' | 'complete'} [status] Status of Compliance Job to list.
         * @param {Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>} [complianceJobFields] A comma separated list of ComplianceJob fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchComplianceJobs: async (type: 'tweets' | 'users', status?: 'created' | 'in_progress' | 'failed' | 'complete', complianceJobFields?: Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'type' is not null or undefined
            assertParamExists('listBatchComplianceJobs', 'type', type)
            const localVarPath = `/2/compliance/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (complianceJobFields) {
                localVarQueryParameter['compliance_job.fields'] = Array.from(complianceJobFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ComplianceApi - functional programming interface
 * @export
 */
export const ComplianceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ComplianceApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a compliance for the given job type
         * @summary Create compliance job
         * @param {CreateComplianceJobRequest} createComplianceJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBatchComplianceJob(createComplianceJobRequest: CreateComplianceJobRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateComplianceJobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBatchComplianceJob(createComplianceJobRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single Compliance Job by ID
         * @summary Get Compliance Job
         * @param {string} id The ID of the Compliance Job to retrieve.
         * @param {Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>} [complianceJobFields] A comma separated list of ComplianceJob fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBatchComplianceJob(id: string, complianceJobFields?: Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2ComplianceJobsIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBatchComplianceJob(id, complianceJobFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Streams 100% of compliance data for Tweets
         * @summary Tweets Compliance stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweet Compliance events will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweet Compliance events will be provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTweetsComplianceStream(partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TweetComplianceStreamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTweetsComplianceStream(partition, backfillMinutes, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Streams 100% of labeling events applied to Tweets
         * @summary Tweets Label stream
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweet labels will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the Tweet labels will be provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTweetsLabelStream(backfillMinutes?: number, startTime?: string, endTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TweetLabelStreamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTweetsLabelStream(backfillMinutes, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Streams 100% of compliance data for Users
         * @summary Users Compliance stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the User Compliance events will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the User Compliance events will be provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersComplianceStream(partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserComplianceStreamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersComplianceStream(partition, backfillMinutes, startTime, endTime, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns recent Compliance Jobs for a given job type and optional job status
         * @summary List Compliance Jobs
         * @param {'tweets' | 'users'} type Type of Compliance Job to list.
         * @param {'created' | 'in_progress' | 'failed' | 'complete'} [status] Status of Compliance Job to list.
         * @param {Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>} [complianceJobFields] A comma separated list of ComplianceJob fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBatchComplianceJobs(type: 'tweets' | 'users', status?: 'created' | 'in_progress' | 'failed' | 'complete', complianceJobFields?: Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2ComplianceJobsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBatchComplianceJobs(type, status, complianceJobFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ComplianceApi - factory interface
 * @export
 */
export const ComplianceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ComplianceApiFp(configuration)
    return {
        /**
         * Creates a compliance for the given job type
         * @summary Create compliance job
         * @param {CreateComplianceJobRequest} createComplianceJobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBatchComplianceJob(createComplianceJobRequest: CreateComplianceJobRequest, options?: any): AxiosPromise<CreateComplianceJobResponse> {
            return localVarFp.createBatchComplianceJob(createComplianceJobRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single Compliance Job by ID
         * @summary Get Compliance Job
         * @param {string} id The ID of the Compliance Job to retrieve.
         * @param {Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>} [complianceJobFields] A comma separated list of ComplianceJob fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBatchComplianceJob(id: string, complianceJobFields?: Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>, options?: any): AxiosPromise<Get2ComplianceJobsIdResponse> {
            return localVarFp.getBatchComplianceJob(id, complianceJobFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams 100% of compliance data for Tweets
         * @summary Tweets Compliance stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweet Compliance events will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweet Compliance events will be provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweetsComplianceStream(partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, options?: any): AxiosPromise<TweetComplianceStreamResponse> {
            return localVarFp.getTweetsComplianceStream(partition, backfillMinutes, startTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams 100% of labeling events applied to Tweets
         * @summary Tweets Label stream
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweet labels will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the Tweet labels will be provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweetsLabelStream(backfillMinutes?: number, startTime?: string, endTime?: string, options?: any): AxiosPromise<TweetLabelStreamResponse> {
            return localVarFp.getTweetsLabelStream(backfillMinutes, startTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams 100% of compliance data for Users
         * @summary Users Compliance stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the User Compliance events will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the User Compliance events will be provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersComplianceStream(partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, options?: any): AxiosPromise<UserComplianceStreamResponse> {
            return localVarFp.getUsersComplianceStream(partition, backfillMinutes, startTime, endTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns recent Compliance Jobs for a given job type and optional job status
         * @summary List Compliance Jobs
         * @param {'tweets' | 'users'} type Type of Compliance Job to list.
         * @param {'created' | 'in_progress' | 'failed' | 'complete'} [status] Status of Compliance Job to list.
         * @param {Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>} [complianceJobFields] A comma separated list of ComplianceJob fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBatchComplianceJobs(type: 'tweets' | 'users', status?: 'created' | 'in_progress' | 'failed' | 'complete', complianceJobFields?: Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>, options?: any): AxiosPromise<Get2ComplianceJobsResponse> {
            return localVarFp.listBatchComplianceJobs(type, status, complianceJobFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComplianceApi - object-oriented interface
 * @export
 * @class ComplianceApi
 * @extends {BaseAPI}
 */
export class ComplianceApi extends BaseAPI {
    /**
     * Creates a compliance for the given job type
     * @summary Create compliance job
     * @param {CreateComplianceJobRequest} createComplianceJobRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public createBatchComplianceJob(createComplianceJobRequest: CreateComplianceJobRequest, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).createBatchComplianceJob(createComplianceJobRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single Compliance Job by ID
     * @summary Get Compliance Job
     * @param {string} id The ID of the Compliance Job to retrieve.
     * @param {Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>} [complianceJobFields] A comma separated list of ComplianceJob fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getBatchComplianceJob(id: string, complianceJobFields?: Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getBatchComplianceJob(id, complianceJobFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams 100% of compliance data for Tweets
     * @summary Tweets Compliance stream
     * @param {number} partition The partition number.
     * @param {number} [backfillMinutes] The number of minutes of backfill requested.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweet Compliance events will be provided.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweet Compliance events will be provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getTweetsComplianceStream(partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getTweetsComplianceStream(partition, backfillMinutes, startTime, endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams 100% of labeling events applied to Tweets
     * @summary Tweets Label stream
     * @param {number} [backfillMinutes] The number of minutes of backfill requested.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweet labels will be provided.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the Tweet labels will be provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getTweetsLabelStream(backfillMinutes?: number, startTime?: string, endTime?: string, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getTweetsLabelStream(backfillMinutes, startTime, endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams 100% of compliance data for Users
     * @summary Users Compliance stream
     * @param {number} partition The partition number.
     * @param {number} [backfillMinutes] The number of minutes of backfill requested.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the User Compliance events will be provided.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the User Compliance events will be provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public getUsersComplianceStream(partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).getUsersComplianceStream(partition, backfillMinutes, startTime, endTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns recent Compliance Jobs for a given job type and optional job status
     * @summary List Compliance Jobs
     * @param {'tweets' | 'users'} type Type of Compliance Job to list.
     * @param {'created' | 'in_progress' | 'failed' | 'complete'} [status] Status of Compliance Job to list.
     * @param {Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>} [complianceJobFields] A comma separated list of ComplianceJob fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComplianceApi
     */
    public listBatchComplianceJobs(type: 'tweets' | 'users', status?: 'created' | 'in_progress' | 'failed' | 'complete', complianceJobFields?: Set<'created_at' | 'download_expires_at' | 'download_url' | 'id' | 'name' | 'resumable' | 'status' | 'type' | 'upload_expires_at' | 'upload_url'>, options?: AxiosRequestConfig) {
        return ComplianceApiFp(this.configuration).listBatchComplianceJobs(type, status, complianceJobFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DirectMessagesApi - axios parameter creator
 * @export
 */
export const DirectMessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new message for a DM Conversation specified by DM Conversation ID
         * @summary Send a new message to a DM Conversation
         * @param {string} dmConversationId The DM Conversation ID.
         * @param {CreateMessageRequest} [createMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dmConversationByIdEventIdCreate: async (dmConversationId: string, createMessageRequest?: CreateMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dmConversationId' is not null or undefined
            assertParamExists('dmConversationByIdEventIdCreate', 'dmConversationId', dmConversationId)
            const localVarPath = `/2/dm_conversations/{dm_conversation_id}/messages`
                .replace(`{${"dm_conversation_id"}}`, encodeURIComponent(String(dmConversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["dm.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new DM Conversation.
         * @summary Create a new DM Conversation
         * @param {CreateDmConversationRequest} [createDmConversationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dmConversationIdCreate: async (createDmConversationRequest?: CreateDmConversationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/dm_conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["dm.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createDmConversationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new message for a DM Conversation with a participant user by ID
         * @summary Send a new message to a user
         * @param {string} participantId The ID of the recipient user that will receive the DM.
         * @param {CreateMessageRequest} [createMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dmConversationWithUserEventIdCreate: async (participantId: string, createMessageRequest?: CreateMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'participantId' is not null or undefined
            assertParamExists('dmConversationWithUserEventIdCreate', 'participantId', participantId)
            const localVarPath = `/2/dm_conversations/with/{participant_id}/messages`
                .replace(`{${"participant_id"}}`, encodeURIComponent(String(participantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["dm.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns DM Events for a DM Conversation
         * @summary Get DM Events for a DM Conversation
         * @param {string} id The DM Conversation ID.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>} [eventTypes] The set of event_types to include in the results.
         * @param {Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>} [dmEventFields] A comma separated list of DmEvent fields to display.
         * @param {Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDmConversationsIdDmEvents: async (id: string, maxResults?: number, paginationToken?: string, eventTypes?: Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>, dmEventFields?: Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>, expansions?: Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDmConversationsIdDmEvents', 'id', id)
            const localVarPath = `/2/dm_conversations/{id}/dm_events`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["dm.read", "tweet.read", "users.read"], configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (eventTypes) {
                localVarQueryParameter['event_types'] = Array.from(eventTypes).join(COLLECTION_FORMATS.csv);
            }

            if (dmEventFields) {
                localVarQueryParameter['dm_event.fields'] = Array.from(dmEventFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns DM Events for a DM Conversation
         * @summary Get DM Events for a DM Conversation
         * @param {string} participantId The ID of the participant user for the One to One DM conversation.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>} [eventTypes] The set of event_types to include in the results.
         * @param {Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>} [dmEventFields] A comma separated list of DmEvent fields to display.
         * @param {Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDmConversationsWithParticipantIdDmEvents: async (participantId: string, maxResults?: number, paginationToken?: string, eventTypes?: Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>, dmEventFields?: Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>, expansions?: Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'participantId' is not null or undefined
            assertParamExists('getDmConversationsWithParticipantIdDmEvents', 'participantId', participantId)
            const localVarPath = `/2/dm_conversations/with/{participant_id}/dm_events`
                .replace(`{${"participant_id"}}`, encodeURIComponent(String(participantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["dm.read", "tweet.read", "users.read"], configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (eventTypes) {
                localVarQueryParameter['event_types'] = Array.from(eventTypes).join(COLLECTION_FORMATS.csv);
            }

            if (dmEventFields) {
                localVarQueryParameter['dm_event.fields'] = Array.from(dmEventFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns recent DM Events across DM conversations
         * @summary Get recent DM Events
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>} [eventTypes] The set of event_types to include in the results.
         * @param {Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>} [dmEventFields] A comma separated list of DmEvent fields to display.
         * @param {Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDmEvents: async (maxResults?: number, paginationToken?: string, eventTypes?: Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>, dmEventFields?: Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>, expansions?: Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/dm_events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["dm.read", "tweet.read", "users.read"], configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (eventTypes) {
                localVarQueryParameter['event_types'] = Array.from(eventTypes).join(COLLECTION_FORMATS.csv);
            }

            if (dmEventFields) {
                localVarQueryParameter['dm_event.fields'] = Array.from(dmEventFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DirectMessagesApi - functional programming interface
 * @export
 */
export const DirectMessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DirectMessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new message for a DM Conversation specified by DM Conversation ID
         * @summary Send a new message to a DM Conversation
         * @param {string} dmConversationId The DM Conversation ID.
         * @param {CreateMessageRequest} [createMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dmConversationByIdEventIdCreate(dmConversationId: string, createMessageRequest?: CreateMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDmEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dmConversationByIdEventIdCreate(dmConversationId, createMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new DM Conversation.
         * @summary Create a new DM Conversation
         * @param {CreateDmConversationRequest} [createDmConversationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dmConversationIdCreate(createDmConversationRequest?: CreateDmConversationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDmEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dmConversationIdCreate(createDmConversationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new message for a DM Conversation with a participant user by ID
         * @summary Send a new message to a user
         * @param {string} participantId The ID of the recipient user that will receive the DM.
         * @param {CreateMessageRequest} [createMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dmConversationWithUserEventIdCreate(participantId: string, createMessageRequest?: CreateMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDmEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dmConversationWithUserEventIdCreate(participantId, createMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns DM Events for a DM Conversation
         * @summary Get DM Events for a DM Conversation
         * @param {string} id The DM Conversation ID.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>} [eventTypes] The set of event_types to include in the results.
         * @param {Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>} [dmEventFields] A comma separated list of DmEvent fields to display.
         * @param {Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDmConversationsIdDmEvents(id: string, maxResults?: number, paginationToken?: string, eventTypes?: Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>, dmEventFields?: Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>, expansions?: Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2DmConversationsIdDmEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDmConversationsIdDmEvents(id, maxResults, paginationToken, eventTypes, dmEventFields, expansions, mediaFields, userFields, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns DM Events for a DM Conversation
         * @summary Get DM Events for a DM Conversation
         * @param {string} participantId The ID of the participant user for the One to One DM conversation.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>} [eventTypes] The set of event_types to include in the results.
         * @param {Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>} [dmEventFields] A comma separated list of DmEvent fields to display.
         * @param {Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDmConversationsWithParticipantIdDmEvents(participantId: string, maxResults?: number, paginationToken?: string, eventTypes?: Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>, dmEventFields?: Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>, expansions?: Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2DmConversationsWithParticipantIdDmEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDmConversationsWithParticipantIdDmEvents(participantId, maxResults, paginationToken, eventTypes, dmEventFields, expansions, mediaFields, userFields, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns recent DM Events across DM conversations
         * @summary Get recent DM Events
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>} [eventTypes] The set of event_types to include in the results.
         * @param {Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>} [dmEventFields] A comma separated list of DmEvent fields to display.
         * @param {Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDmEvents(maxResults?: number, paginationToken?: string, eventTypes?: Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>, dmEventFields?: Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>, expansions?: Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2DmEventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDmEvents(maxResults, paginationToken, eventTypes, dmEventFields, expansions, mediaFields, userFields, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DirectMessagesApi - factory interface
 * @export
 */
export const DirectMessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DirectMessagesApiFp(configuration)
    return {
        /**
         * Creates a new message for a DM Conversation specified by DM Conversation ID
         * @summary Send a new message to a DM Conversation
         * @param {string} dmConversationId The DM Conversation ID.
         * @param {CreateMessageRequest} [createMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dmConversationByIdEventIdCreate(dmConversationId: string, createMessageRequest?: CreateMessageRequest, options?: any): AxiosPromise<CreateDmEventResponse> {
            return localVarFp.dmConversationByIdEventIdCreate(dmConversationId, createMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new DM Conversation.
         * @summary Create a new DM Conversation
         * @param {CreateDmConversationRequest} [createDmConversationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dmConversationIdCreate(createDmConversationRequest?: CreateDmConversationRequest, options?: any): AxiosPromise<CreateDmEventResponse> {
            return localVarFp.dmConversationIdCreate(createDmConversationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new message for a DM Conversation with a participant user by ID
         * @summary Send a new message to a user
         * @param {string} participantId The ID of the recipient user that will receive the DM.
         * @param {CreateMessageRequest} [createMessageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dmConversationWithUserEventIdCreate(participantId: string, createMessageRequest?: CreateMessageRequest, options?: any): AxiosPromise<CreateDmEventResponse> {
            return localVarFp.dmConversationWithUserEventIdCreate(participantId, createMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns DM Events for a DM Conversation
         * @summary Get DM Events for a DM Conversation
         * @param {string} id The DM Conversation ID.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>} [eventTypes] The set of event_types to include in the results.
         * @param {Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>} [dmEventFields] A comma separated list of DmEvent fields to display.
         * @param {Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDmConversationsIdDmEvents(id: string, maxResults?: number, paginationToken?: string, eventTypes?: Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>, dmEventFields?: Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>, expansions?: Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2DmConversationsIdDmEventsResponse> {
            return localVarFp.getDmConversationsIdDmEvents(id, maxResults, paginationToken, eventTypes, dmEventFields, expansions, mediaFields, userFields, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns DM Events for a DM Conversation
         * @summary Get DM Events for a DM Conversation
         * @param {string} participantId The ID of the participant user for the One to One DM conversation.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>} [eventTypes] The set of event_types to include in the results.
         * @param {Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>} [dmEventFields] A comma separated list of DmEvent fields to display.
         * @param {Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDmConversationsWithParticipantIdDmEvents(participantId: string, maxResults?: number, paginationToken?: string, eventTypes?: Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>, dmEventFields?: Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>, expansions?: Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2DmConversationsWithParticipantIdDmEventsResponse> {
            return localVarFp.getDmConversationsWithParticipantIdDmEvents(participantId, maxResults, paginationToken, eventTypes, dmEventFields, expansions, mediaFields, userFields, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns recent DM Events across DM conversations
         * @summary Get recent DM Events
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>} [eventTypes] The set of event_types to include in the results.
         * @param {Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>} [dmEventFields] A comma separated list of DmEvent fields to display.
         * @param {Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDmEvents(maxResults?: number, paginationToken?: string, eventTypes?: Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>, dmEventFields?: Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>, expansions?: Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2DmEventsResponse> {
            return localVarFp.getDmEvents(maxResults, paginationToken, eventTypes, dmEventFields, expansions, mediaFields, userFields, tweetFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DirectMessagesApi - object-oriented interface
 * @export
 * @class DirectMessagesApi
 * @extends {BaseAPI}
 */
export class DirectMessagesApi extends BaseAPI {
    /**
     * Creates a new message for a DM Conversation specified by DM Conversation ID
     * @summary Send a new message to a DM Conversation
     * @param {string} dmConversationId The DM Conversation ID.
     * @param {CreateMessageRequest} [createMessageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectMessagesApi
     */
    public dmConversationByIdEventIdCreate(dmConversationId: string, createMessageRequest?: CreateMessageRequest, options?: AxiosRequestConfig) {
        return DirectMessagesApiFp(this.configuration).dmConversationByIdEventIdCreate(dmConversationId, createMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new DM Conversation.
     * @summary Create a new DM Conversation
     * @param {CreateDmConversationRequest} [createDmConversationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectMessagesApi
     */
    public dmConversationIdCreate(createDmConversationRequest?: CreateDmConversationRequest, options?: AxiosRequestConfig) {
        return DirectMessagesApiFp(this.configuration).dmConversationIdCreate(createDmConversationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new message for a DM Conversation with a participant user by ID
     * @summary Send a new message to a user
     * @param {string} participantId The ID of the recipient user that will receive the DM.
     * @param {CreateMessageRequest} [createMessageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectMessagesApi
     */
    public dmConversationWithUserEventIdCreate(participantId: string, createMessageRequest?: CreateMessageRequest, options?: AxiosRequestConfig) {
        return DirectMessagesApiFp(this.configuration).dmConversationWithUserEventIdCreate(participantId, createMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns DM Events for a DM Conversation
     * @summary Get DM Events for a DM Conversation
     * @param {string} id The DM Conversation ID.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>} [eventTypes] The set of event_types to include in the results.
     * @param {Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>} [dmEventFields] A comma separated list of DmEvent fields to display.
     * @param {Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectMessagesApi
     */
    public getDmConversationsIdDmEvents(id: string, maxResults?: number, paginationToken?: string, eventTypes?: Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>, dmEventFields?: Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>, expansions?: Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return DirectMessagesApiFp(this.configuration).getDmConversationsIdDmEvents(id, maxResults, paginationToken, eventTypes, dmEventFields, expansions, mediaFields, userFields, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns DM Events for a DM Conversation
     * @summary Get DM Events for a DM Conversation
     * @param {string} participantId The ID of the participant user for the One to One DM conversation.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>} [eventTypes] The set of event_types to include in the results.
     * @param {Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>} [dmEventFields] A comma separated list of DmEvent fields to display.
     * @param {Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectMessagesApi
     */
    public getDmConversationsWithParticipantIdDmEvents(participantId: string, maxResults?: number, paginationToken?: string, eventTypes?: Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>, dmEventFields?: Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>, expansions?: Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return DirectMessagesApiFp(this.configuration).getDmConversationsWithParticipantIdDmEvents(participantId, maxResults, paginationToken, eventTypes, dmEventFields, expansions, mediaFields, userFields, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns recent DM Events across DM conversations
     * @summary Get recent DM Events
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>} [eventTypes] The set of event_types to include in the results.
     * @param {Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>} [dmEventFields] A comma separated list of DmEvent fields to display.
     * @param {Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DirectMessagesApi
     */
    public getDmEvents(maxResults?: number, paginationToken?: string, eventTypes?: Set<'MessageCreate' | 'ParticipantsJoin' | 'ParticipantsLeave'>, dmEventFields?: Set<'attachments' | 'created_at' | 'dm_conversation_id' | 'event_type' | 'id' | 'participant_ids' | 'referenced_tweets' | 'sender_id' | 'text'>, expansions?: Set<'attachments.media_keys' | 'participant_ids' | 'referenced_tweets.id' | 'sender_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return DirectMessagesApiFp(this.configuration).getDmEvents(maxResults, paginationToken, eventTypes, dmEventFields, expansions, mediaFields, userFields, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * GeneralApi - axios parameter creator
 * @export
 */
export const GeneralApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Full OpenAPI Specification in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
         * @summary Returns the OpenAPI Specification document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenApiSpec: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/openapi.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GeneralApi - functional programming interface
 * @export
 */
export const GeneralApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GeneralApiAxiosParamCreator(configuration)
    return {
        /**
         * Full OpenAPI Specification in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
         * @summary Returns the OpenAPI Specification document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenApiSpec(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenApiSpec(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GeneralApi - factory interface
 * @export
 */
export const GeneralApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GeneralApiFp(configuration)
    return {
        /**
         * Full OpenAPI Specification in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
         * @summary Returns the OpenAPI Specification document.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenApiSpec(options?: any): AxiosPromise<object> {
            return localVarFp.getOpenApiSpec(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GeneralApi - object-oriented interface
 * @export
 * @class GeneralApi
 * @extends {BaseAPI}
 */
export class GeneralApi extends BaseAPI {
    /**
     * Full OpenAPI Specification in JSON format. (See https://github.com/OAI/OpenAPI-Specification/blob/master/README.md)
     * @summary Returns the OpenAPI Specification document.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeneralApi
     */
    public getOpenApiSpec(options?: AxiosRequestConfig) {
        return GeneralApiFp(this.configuration).getOpenApiSpec(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ListsApi - axios parameter creator
 * @export
 */
export const ListsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a User\'s List Memberships.
         * @summary Get a User\'s List Memberships
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserListMemberships: async (id: string, maxResults?: number, paginationToken?: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserListMemberships', 'id', id)
            const localVarPath = `/2/users/{id}/list_memberships`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (listFields) {
                localVarQueryParameter['list.fields'] = Array.from(listFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes a User to become a member of a List.
         * @summary Add a List member
         * @param {string} id The ID of the List for which to add a member.
         * @param {ListAddUserRequest} [listAddUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddMember: async (id: string, listAddUserRequest?: ListAddUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listAddMember', 'id', id)
            const localVarPath = `/2/lists/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listAddUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new List.
         * @summary Create List
         * @param {ListCreateRequest} [listCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdCreate: async (listCreateRequest?: ListCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/lists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.read", "list.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a List that you own.
         * @summary Delete List
         * @param {string} id The ID of the List to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listIdDelete', 'id', id)
            const localVarPath = `/2/lists/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a List.
         * @summary List lookup by List ID.
         * @param {string} id The ID of the List.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdGet: async (id: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listIdGet', 'id', id)
            const localVarPath = `/2/lists/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (listFields) {
                localVarQueryParameter['list.fields'] = Array.from(listFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a List that you own.
         * @summary Update List.
         * @param {string} id The ID of the List to modify.
         * @param {ListUpdateRequest} [listUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdUpdate: async (id: string, listUpdateRequest?: ListUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listIdUpdate', 'id', id)
            const localVarPath = `/2/lists/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes a User to be removed from the members of a List.
         * @summary Remove a List member
         * @param {string} id The ID of the List to remove a member.
         * @param {string} userId The ID of User that will be removed from the List.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRemoveMember: async (id: string, userId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listRemoveMember', 'id', id)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('listRemoveMember', 'userId', userId)
            const localVarPath = `/2/lists/{id}/members/{user_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes a User to follow a List.
         * @summary Follow a List
         * @param {string} id The ID of the authenticated source User that will follow the List.
         * @param {ListFollowedRequest} [listFollowedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserFollow: async (id: string, listFollowedRequest?: ListFollowedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listUserFollow', 'id', id)
            const localVarPath = `/2/users/{id}/followed_lists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listFollowedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a User\'s Owned Lists.
         * @summary Get a User\'s Owned Lists.
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserOwnedLists: async (id: string, maxResults?: number, paginationToken?: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listUserOwnedLists', 'id', id)
            const localVarPath = `/2/users/{id}/owned_lists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (listFields) {
                localVarQueryParameter['list.fields'] = Array.from(listFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes a User to pin a List.
         * @summary Pin a List
         * @param {string} id The ID of the authenticated source User that will pin the List.
         * @param {ListPinnedRequest} listPinnedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPin: async (id: string, listPinnedRequest: ListPinnedRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listUserPin', 'id', id)
            // verify required parameter 'listPinnedRequest' is not null or undefined
            assertParamExists('listUserPin', 'listPinnedRequest', listPinnedRequest)
            const localVarPath = `/2/users/{id}/pinned_lists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listPinnedRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a User\'s Pinned Lists.
         * @summary Get a User\'s Pinned Lists
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPinnedLists: async (id: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listUserPinnedLists', 'id', id)
            const localVarPath = `/2/users/{id}/pinned_lists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.read", "tweet.read", "users.read"], configuration)

            // authentication UserToken required

            if (listFields) {
                localVarQueryParameter['list.fields'] = Array.from(listFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes a User to unfollow a List.
         * @summary Unfollow a List
         * @param {string} id The ID of the authenticated source User that will unfollow the List.
         * @param {string} listId The ID of the List to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserUnfollow: async (id: string, listId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listUserUnfollow', 'id', id)
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('listUserUnfollow', 'listId', listId)
            const localVarPath = `/2/users/{id}/followed_lists/{list_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes a User to remove a pinned List.
         * @summary Unpin a List
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {string} listId The ID of the List to unpin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserUnpin: async (id: string, listId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listUserUnpin', 'id', id)
            // verify required parameter 'listId' is not null or undefined
            assertParamExists('listUserUnpin', 'listId', listId)
            const localVarPath = `/2/users/{id}/pinned_lists/{list_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"list_id"}}`, encodeURIComponent(String(listId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a User\'s followed Lists.
         * @summary Get User\'s Followed Lists
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFollowedLists: async (id: string, maxResults?: number, paginationToken?: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userFollowedLists', 'id', id)
            const localVarPath = `/2/users/{id}/followed_lists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (listFields) {
                localVarQueryParameter['list.fields'] = Array.from(listFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ListsApi - functional programming interface
 * @export
 */
export const ListsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ListsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a User\'s List Memberships.
         * @summary Get a User\'s List Memberships
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserListMemberships(id: string, maxResults?: number, paginationToken?: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdListMembershipsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserListMemberships(id, maxResults, paginationToken, listFields, expansions, userFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes a User to become a member of a List.
         * @summary Add a List member
         * @param {string} id The ID of the List for which to add a member.
         * @param {ListAddUserRequest} [listAddUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAddMember(id: string, listAddUserRequest?: ListAddUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMutateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAddMember(id, listAddUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a new List.
         * @summary Create List
         * @param {ListCreateRequest} [listCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIdCreate(listCreateRequest?: ListCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdCreate(listCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a List that you own.
         * @summary Delete List
         * @param {string} id The ID of the List to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIdDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a List.
         * @summary List lookup by List ID.
         * @param {string} id The ID of the List.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIdGet(id: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2ListsIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdGet(id, listFields, expansions, userFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a List that you own.
         * @summary Update List.
         * @param {string} id The ID of the List to modify.
         * @param {ListUpdateRequest} [listUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIdUpdate(id: string, listUpdateRequest?: ListUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIdUpdate(id, listUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes a User to be removed from the members of a List.
         * @summary Remove a List member
         * @param {string} id The ID of the List to remove a member.
         * @param {string} userId The ID of User that will be removed from the List.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRemoveMember(id: string, userId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListMutateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRemoveMember(id, userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes a User to follow a List.
         * @summary Follow a List
         * @param {string} id The ID of the authenticated source User that will follow the List.
         * @param {ListFollowedRequest} [listFollowedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserFollow(id: string, listFollowedRequest?: ListFollowedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFollowedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserFollow(id, listFollowedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a User\'s Owned Lists.
         * @summary Get a User\'s Owned Lists.
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserOwnedLists(id: string, maxResults?: number, paginationToken?: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdOwnedListsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserOwnedLists(id, maxResults, paginationToken, listFields, expansions, userFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes a User to pin a List.
         * @summary Pin a List
         * @param {string} id The ID of the authenticated source User that will pin the List.
         * @param {ListPinnedRequest} listPinnedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserPin(id: string, listPinnedRequest: ListPinnedRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPinnedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserPin(id, listPinnedRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a User\'s Pinned Lists.
         * @summary Get a User\'s Pinned Lists
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserPinnedLists(id: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdPinnedListsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserPinnedLists(id, listFields, expansions, userFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes a User to unfollow a List.
         * @summary Unfollow a List
         * @param {string} id The ID of the authenticated source User that will unfollow the List.
         * @param {string} listId The ID of the List to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserUnfollow(id: string, listId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFollowedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserUnfollow(id, listId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes a User to remove a pinned List.
         * @summary Unpin a List
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {string} listId The ID of the List to unpin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserUnpin(id: string, listId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListUnpinResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserUnpin(id, listId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a User\'s followed Lists.
         * @summary Get User\'s Followed Lists
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userFollowedLists(id: string, maxResults?: number, paginationToken?: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdFollowedListsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userFollowedLists(id, maxResults, paginationToken, listFields, expansions, userFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ListsApi - factory interface
 * @export
 */
export const ListsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ListsApiFp(configuration)
    return {
        /**
         * Get a User\'s List Memberships.
         * @summary Get a User\'s List Memberships
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserListMemberships(id: string, maxResults?: number, paginationToken?: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: any): AxiosPromise<Get2UsersIdListMembershipsResponse> {
            return localVarFp.getUserListMemberships(id, maxResults, paginationToken, listFields, expansions, userFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes a User to become a member of a List.
         * @summary Add a List member
         * @param {string} id The ID of the List for which to add a member.
         * @param {ListAddUserRequest} [listAddUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAddMember(id: string, listAddUserRequest?: ListAddUserRequest, options?: any): AxiosPromise<ListMutateResponse> {
            return localVarFp.listAddMember(id, listAddUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new List.
         * @summary Create List
         * @param {ListCreateRequest} [listCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdCreate(listCreateRequest?: ListCreateRequest, options?: any): AxiosPromise<ListCreateResponse> {
            return localVarFp.listIdCreate(listCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a List that you own.
         * @summary Delete List
         * @param {string} id The ID of the List to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdDelete(id: string, options?: any): AxiosPromise<ListDeleteResponse> {
            return localVarFp.listIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a List.
         * @summary List lookup by List ID.
         * @param {string} id The ID of the List.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdGet(id: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: any): AxiosPromise<Get2ListsIdResponse> {
            return localVarFp.listIdGet(id, listFields, expansions, userFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a List that you own.
         * @summary Update List.
         * @param {string} id The ID of the List to modify.
         * @param {ListUpdateRequest} [listUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIdUpdate(id: string, listUpdateRequest?: ListUpdateRequest, options?: any): AxiosPromise<ListUpdateResponse> {
            return localVarFp.listIdUpdate(id, listUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes a User to be removed from the members of a List.
         * @summary Remove a List member
         * @param {string} id The ID of the List to remove a member.
         * @param {string} userId The ID of User that will be removed from the List.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRemoveMember(id: string, userId: string, options?: any): AxiosPromise<ListMutateResponse> {
            return localVarFp.listRemoveMember(id, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes a User to follow a List.
         * @summary Follow a List
         * @param {string} id The ID of the authenticated source User that will follow the List.
         * @param {ListFollowedRequest} [listFollowedRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserFollow(id: string, listFollowedRequest?: ListFollowedRequest, options?: any): AxiosPromise<ListFollowedResponse> {
            return localVarFp.listUserFollow(id, listFollowedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a User\'s Owned Lists.
         * @summary Get a User\'s Owned Lists.
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserOwnedLists(id: string, maxResults?: number, paginationToken?: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: any): AxiosPromise<Get2UsersIdOwnedListsResponse> {
            return localVarFp.listUserOwnedLists(id, maxResults, paginationToken, listFields, expansions, userFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes a User to pin a List.
         * @summary Pin a List
         * @param {string} id The ID of the authenticated source User that will pin the List.
         * @param {ListPinnedRequest} listPinnedRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPin(id: string, listPinnedRequest: ListPinnedRequest, options?: any): AxiosPromise<ListPinnedResponse> {
            return localVarFp.listUserPin(id, listPinnedRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a User\'s Pinned Lists.
         * @summary Get a User\'s Pinned Lists
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPinnedLists(id: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: any): AxiosPromise<Get2UsersIdPinnedListsResponse> {
            return localVarFp.listUserPinnedLists(id, listFields, expansions, userFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes a User to unfollow a List.
         * @summary Unfollow a List
         * @param {string} id The ID of the authenticated source User that will unfollow the List.
         * @param {string} listId The ID of the List to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserUnfollow(id: string, listId: string, options?: any): AxiosPromise<ListFollowedResponse> {
            return localVarFp.listUserUnfollow(id, listId, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes a User to remove a pinned List.
         * @summary Unpin a List
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {string} listId The ID of the List to unpin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserUnpin(id: string, listId: string, options?: any): AxiosPromise<ListUnpinResponse> {
            return localVarFp.listUserUnpin(id, listId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a User\'s followed Lists.
         * @summary Get User\'s Followed Lists
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
         * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFollowedLists(id: string, maxResults?: number, paginationToken?: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: any): AxiosPromise<Get2UsersIdFollowedListsResponse> {
            return localVarFp.userFollowedLists(id, maxResults, paginationToken, listFields, expansions, userFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ListsApi - object-oriented interface
 * @export
 * @class ListsApi
 * @extends {BaseAPI}
 */
export class ListsApi extends BaseAPI {
    /**
     * Get a User\'s List Memberships.
     * @summary Get a User\'s List Memberships
     * @param {string} id The ID of the User to lookup.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
     * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public getUserListMemberships(id: string, maxResults?: number, paginationToken?: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).getUserListMemberships(id, maxResults, paginationToken, listFields, expansions, userFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes a User to become a member of a List.
     * @summary Add a List member
     * @param {string} id The ID of the List for which to add a member.
     * @param {ListAddUserRequest} [listAddUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public listAddMember(id: string, listAddUserRequest?: ListAddUserRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listAddMember(id, listAddUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new List.
     * @summary Create List
     * @param {ListCreateRequest} [listCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public listIdCreate(listCreateRequest?: ListCreateRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listIdCreate(listCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a List that you own.
     * @summary Delete List
     * @param {string} id The ID of the List to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public listIdDelete(id: string, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a List.
     * @summary List lookup by List ID.
     * @param {string} id The ID of the List.
     * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
     * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public listIdGet(id: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listIdGet(id, listFields, expansions, userFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a List that you own.
     * @summary Update List.
     * @param {string} id The ID of the List to modify.
     * @param {ListUpdateRequest} [listUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public listIdUpdate(id: string, listUpdateRequest?: ListUpdateRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listIdUpdate(id, listUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes a User to be removed from the members of a List.
     * @summary Remove a List member
     * @param {string} id The ID of the List to remove a member.
     * @param {string} userId The ID of User that will be removed from the List.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public listRemoveMember(id: string, userId: string, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listRemoveMember(id, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes a User to follow a List.
     * @summary Follow a List
     * @param {string} id The ID of the authenticated source User that will follow the List.
     * @param {ListFollowedRequest} [listFollowedRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public listUserFollow(id: string, listFollowedRequest?: ListFollowedRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listUserFollow(id, listFollowedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a User\'s Owned Lists.
     * @summary Get a User\'s Owned Lists.
     * @param {string} id The ID of the User to lookup.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
     * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public listUserOwnedLists(id: string, maxResults?: number, paginationToken?: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listUserOwnedLists(id, maxResults, paginationToken, listFields, expansions, userFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes a User to pin a List.
     * @summary Pin a List
     * @param {string} id The ID of the authenticated source User that will pin the List.
     * @param {ListPinnedRequest} listPinnedRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public listUserPin(id: string, listPinnedRequest: ListPinnedRequest, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listUserPin(id, listPinnedRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a User\'s Pinned Lists.
     * @summary Get a User\'s Pinned Lists
     * @param {string} id The ID of the authenticated source User for whom to return results.
     * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
     * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public listUserPinnedLists(id: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listUserPinnedLists(id, listFields, expansions, userFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes a User to unfollow a List.
     * @summary Unfollow a List
     * @param {string} id The ID of the authenticated source User that will unfollow the List.
     * @param {string} listId The ID of the List to unfollow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public listUserUnfollow(id: string, listId: string, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listUserUnfollow(id, listId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes a User to remove a pinned List.
     * @summary Unpin a List
     * @param {string} id The ID of the authenticated source User for whom to return results.
     * @param {string} listId The ID of the List to unpin.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public listUserUnpin(id: string, listId: string, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).listUserUnpin(id, listId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a User\'s followed Lists.
     * @summary Get User\'s Followed Lists
     * @param {string} id The ID of the User to lookup.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>} [listFields] A comma separated list of List fields to display.
     * @param {Set<'owner_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ListsApi
     */
    public userFollowedLists(id: string, maxResults?: number, paginationToken?: string, listFields?: Set<'created_at' | 'description' | 'follower_count' | 'id' | 'member_count' | 'name' | 'owner_id' | 'private'>, expansions?: Set<'owner_id'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, options?: AxiosRequestConfig) {
        return ListsApiFp(this.configuration).userFollowedLists(id, maxResults, paginationToken, listFields, expansions, userFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpacesApi - axios parameter creator
 * @export
 */
export const SpacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a variety of information about the Space specified by the requested ID
         * @summary Space lookup by Space ID
         * @param {string} id The ID of the Space to be retrieved.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSpaceById: async (id: string, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findSpaceById', 'id', id)
            const localVarPath = `/2/spaces/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (spaceFields) {
                localVarQueryParameter['space.fields'] = Array.from(spaceFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (topicFields) {
                localVarQueryParameter['topic.fields'] = Array.from(topicFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a variety of information about the Spaces created by the provided User IDs
         * @summary Space lookup by their creators
         * @param {Array<string>} userIds The IDs of Users to search through.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSpacesByCreatorIds: async (userIds: Array<string>, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userIds' is not null or undefined
            assertParamExists('findSpacesByCreatorIds', 'userIds', userIds)
            const localVarPath = `/2/spaces/by/creator_ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (userIds) {
                localVarQueryParameter['user_ids'] = userIds;
            }

            if (spaceFields) {
                localVarQueryParameter['space.fields'] = Array.from(spaceFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (topicFields) {
                localVarQueryParameter['topic.fields'] = Array.from(topicFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a variety of information about the Spaces specified by the requested IDs
         * @summary Space lookup up Space IDs
         * @param {Array<string>} ids The list of Space IDs to return.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSpacesByIds: async (ids: Array<string>, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('findSpacesByIds', 'ids', ids)
            const localVarPath = `/2/spaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (spaceFields) {
                localVarQueryParameter['space.fields'] = Array.from(spaceFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (topicFields) {
                localVarQueryParameter['topic.fields'] = Array.from(topicFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Spaces that match the provided query.
         * @summary Search for Spaces
         * @param {string} query The search query.
         * @param {'live' | 'scheduled' | 'all'} [state] The state of Spaces to search for.
         * @param {number} [maxResults] The number of results to return.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSpaces: async (query: string, state?: 'live' | 'scheduled' | 'all', maxResults?: number, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchSpaces', 'query', query)
            const localVarPath = `/2/spaces/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (spaceFields) {
                localVarQueryParameter['space.fields'] = Array.from(spaceFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (topicFields) {
                localVarQueryParameter['topic.fields'] = Array.from(topicFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of Users who purchased a ticket to the given space
         * @summary Retrieve the list of Users who purchased a ticket to the given space
         * @param {string} id The ID of the Space to be retrieved.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spaceBuyers: async (id: string, paginationToken?: string, maxResults?: number, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('spaceBuyers', 'id', id)
            const localVarPath = `/2/spaces/{id}/buyers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves Tweets shared in the specified Space.
         * @summary Retrieve Tweets from a Space.
         * @param {string} id The ID of the Space to be retrieved.
         * @param {number} [maxResults] The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spaceTweets: async (id: string, maxResults?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('spaceTweets', 'id', id)
            const localVarPath = `/2/spaces/{id}/tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpacesApi - functional programming interface
 * @export
 */
export const SpacesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpacesApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a variety of information about the Space specified by the requested ID
         * @summary Space lookup by Space ID
         * @param {string} id The ID of the Space to be retrieved.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSpaceById(id: string, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSpaceById(id, spaceFields, expansions, userFields, topicFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a variety of information about the Spaces created by the provided User IDs
         * @summary Space lookup by their creators
         * @param {Array<string>} userIds The IDs of Users to search through.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSpacesByCreatorIds(userIds: Array<string>, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesByCreatorIdsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSpacesByCreatorIds(userIds, spaceFields, expansions, userFields, topicFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a variety of information about the Spaces specified by the requested IDs
         * @summary Space lookup up Space IDs
         * @param {Array<string>} ids The list of Space IDs to return.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSpacesByIds(ids: Array<string>, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSpacesByIds(ids, spaceFields, expansions, userFields, topicFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Spaces that match the provided query.
         * @summary Search for Spaces
         * @param {string} query The search query.
         * @param {'live' | 'scheduled' | 'all'} [state] The state of Spaces to search for.
         * @param {number} [maxResults] The number of results to return.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSpaces(query: string, state?: 'live' | 'scheduled' | 'all', maxResults?: number, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSpaces(query, state, maxResults, spaceFields, expansions, userFields, topicFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of Users who purchased a ticket to the given space
         * @summary Retrieve the list of Users who purchased a ticket to the given space
         * @param {string} id The ID of the Space to be retrieved.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spaceBuyers(id: string, paginationToken?: string, maxResults?: number, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesIdBuyersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spaceBuyers(id, paginationToken, maxResults, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves Tweets shared in the specified Space.
         * @summary Retrieve Tweets from a Space.
         * @param {string} id The ID of the Space to be retrieved.
         * @param {number} [maxResults] The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spaceTweets(id: string, maxResults?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesIdTweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spaceTweets(id, maxResults, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SpacesApi - factory interface
 * @export
 */
export const SpacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpacesApiFp(configuration)
    return {
        /**
         * Returns a variety of information about the Space specified by the requested ID
         * @summary Space lookup by Space ID
         * @param {string} id The ID of the Space to be retrieved.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSpaceById(id: string, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options?: any): AxiosPromise<Get2SpacesIdResponse> {
            return localVarFp.findSpaceById(id, spaceFields, expansions, userFields, topicFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a variety of information about the Spaces created by the provided User IDs
         * @summary Space lookup by their creators
         * @param {Array<string>} userIds The IDs of Users to search through.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSpacesByCreatorIds(userIds: Array<string>, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options?: any): AxiosPromise<Get2SpacesByCreatorIdsResponse> {
            return localVarFp.findSpacesByCreatorIds(userIds, spaceFields, expansions, userFields, topicFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a variety of information about the Spaces specified by the requested IDs
         * @summary Space lookup up Space IDs
         * @param {Array<string>} ids The list of Space IDs to return.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSpacesByIds(ids: Array<string>, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options?: any): AxiosPromise<Get2SpacesResponse> {
            return localVarFp.findSpacesByIds(ids, spaceFields, expansions, userFields, topicFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Spaces that match the provided query.
         * @summary Search for Spaces
         * @param {string} query The search query.
         * @param {'live' | 'scheduled' | 'all'} [state] The state of Spaces to search for.
         * @param {number} [maxResults] The number of results to return.
         * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
         * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSpaces(query: string, state?: 'live' | 'scheduled' | 'all', maxResults?: number, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options?: any): AxiosPromise<Get2SpacesSearchResponse> {
            return localVarFp.searchSpaces(query, state, maxResults, spaceFields, expansions, userFields, topicFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of Users who purchased a ticket to the given space
         * @summary Retrieve the list of Users who purchased a ticket to the given space
         * @param {string} id The ID of the Space to be retrieved.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spaceBuyers(id: string, paginationToken?: string, maxResults?: number, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2SpacesIdBuyersResponse> {
            return localVarFp.spaceBuyers(id, paginationToken, maxResults, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves Tweets shared in the specified Space.
         * @summary Retrieve Tweets from a Space.
         * @param {string} id The ID of the Space to be retrieved.
         * @param {number} [maxResults] The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spaceTweets(id: string, maxResults?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2SpacesIdTweetsResponse> {
            return localVarFp.spaceTweets(id, maxResults, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpacesApi - object-oriented interface
 * @export
 * @class SpacesApi
 * @extends {BaseAPI}
 */
export class SpacesApi extends BaseAPI {
    /**
     * Returns a variety of information about the Space specified by the requested ID
     * @summary Space lookup by Space ID
     * @param {string} id The ID of the Space to be retrieved.
     * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpacesApi
     */
    public findSpaceById(id: string, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options?: AxiosRequestConfig) {
        return SpacesApiFp(this.configuration).findSpaceById(id, spaceFields, expansions, userFields, topicFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a variety of information about the Spaces created by the provided User IDs
     * @summary Space lookup by their creators
     * @param {Array<string>} userIds The IDs of Users to search through.
     * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpacesApi
     */
    public findSpacesByCreatorIds(userIds: Array<string>, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options?: AxiosRequestConfig) {
        return SpacesApiFp(this.configuration).findSpacesByCreatorIds(userIds, spaceFields, expansions, userFields, topicFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a variety of information about the Spaces specified by the requested IDs
     * @summary Space lookup up Space IDs
     * @param {Array<string>} ids The list of Space IDs to return.
     * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpacesApi
     */
    public findSpacesByIds(ids: Array<string>, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options?: AxiosRequestConfig) {
        return SpacesApiFp(this.configuration).findSpacesByIds(ids, spaceFields, expansions, userFields, topicFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Spaces that match the provided query.
     * @summary Search for Spaces
     * @param {string} query The search query.
     * @param {'live' | 'scheduled' | 'all'} [state] The state of Spaces to search for.
     * @param {number} [maxResults] The number of results to return.
     * @param {Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>} [spaceFields] A comma separated list of Space fields to display.
     * @param {Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'description' | 'id' | 'name'>} [topicFields] A comma separated list of Topic fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpacesApi
     */
    public searchSpaces(query: string, state?: 'live' | 'scheduled' | 'all', maxResults?: number, spaceFields?: Set<'created_at' | 'creator_id' | 'ended_at' | 'host_ids' | 'id' | 'invited_user_ids' | 'is_ticketed' | 'lang' | 'participant_count' | 'scheduled_start' | 'speaker_ids' | 'started_at' | 'state' | 'subscriber_count' | 'title' | 'topic_ids' | 'updated_at'>, expansions?: Set<'creator_id' | 'host_ids' | 'invited_user_ids' | 'speaker_ids' | 'topic_ids'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, topicFields?: Set<'description' | 'id' | 'name'>, options?: AxiosRequestConfig) {
        return SpacesApiFp(this.configuration).searchSpaces(query, state, maxResults, spaceFields, expansions, userFields, topicFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of Users who purchased a ticket to the given space
     * @summary Retrieve the list of Users who purchased a ticket to the given space
     * @param {string} id The ID of the Space to be retrieved.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {number} [maxResults] The maximum number of results.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpacesApi
     */
    public spaceBuyers(id: string, paginationToken?: string, maxResults?: number, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return SpacesApiFp(this.configuration).spaceBuyers(id, paginationToken, maxResults, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves Tweets shared in the specified Space.
     * @summary Retrieve Tweets from a Space.
     * @param {string} id The ID of the Space to be retrieved.
     * @param {number} [maxResults] The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpacesApi
     */
    public spaceTweets(id: string, maxResults?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return SpacesApiFp(this.configuration).spaceTweets(id, maxResults, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TweetsApi - axios parameter creator
 * @export
 */
export const TweetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add or delete rules from a User\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
         * @summary Add/Delete rules
         * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest 
         * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrDeleteRules: async (addOrDeleteRulesRequest: AddOrDeleteRulesRequest, dryRun?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addOrDeleteRulesRequest' is not null or undefined
            assertParamExists('addOrDeleteRules', 'addOrDeleteRulesRequest', addOrDeleteRulesRequest)
            const localVarPath = `/2/tweets/search/stream/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (dryRun !== undefined) {
                localVarQueryParameter['dry_run'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addOrDeleteRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User to create a Tweet under the authorized account.
         * @summary Creation of a Tweet
         * @param {TweetCreateRequest} tweetCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTweet: async (tweetCreateRequest: TweetCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tweetCreateRequest' is not null or undefined
            assertParamExists('createTweet', 'tweetCreateRequest', tweetCreateRequest)
            const localVarPath = `/2/tweets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "tweet.write", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tweetCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete specified Tweet (in the path) by ID.
         * @summary Tweet delete by Tweet ID
         * @param {string} id The ID of the Tweet to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTweetById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteTweetById', 'id', id)
            const localVarPath = `/2/tweets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "tweet.write", "users.read"], configuration)

            // authentication UserToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID.
         * @summary Tweet lookup by Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTweetById: async (id: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findTweetById', 'id', id)
            const localVarPath = `/2/tweets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID.
         * @summary Tweet lookup by Tweet IDs
         * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTweetsById: async (ids: Array<string>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('findTweetsById', 'ids', ids)
            const localVarPath = `/2/tweets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.
         * @summary Retrieve Tweets that quote a Tweet.
         * @param {string} id A single Tweet ID.
         * @param {number} [maxResults] The maximum number of results to be returned.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTweetsThatQuoteATweet: async (id: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findTweetsThatQuoteATweet', 'id', id)
            const localVarPath = `/2/tweets/{id}/quote_tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (exclude) {
                localVarQueryParameter['exclude'] = Array.from(exclude).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns rules from a User\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
         * @summary Rules lookup
         * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; returned in a request to paginate through results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRules: async (ids?: Array<string>, maxResults?: number, paginationToken?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/tweets/search/stream/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (ids) {
                localVarQueryParameter['ids'] = ids;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams 100% of public Tweets.
         * @summary Firehose stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweetsFirehoseStream: async (partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partition' is not null or undefined
            assertParamExists('getTweetsFirehoseStream', 'partition', partition)
            const localVarPath = `/2/tweets/firehose/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (backfillMinutes !== undefined) {
                localVarQueryParameter['backfill_minutes'] = backfillMinutes;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams a deterministic 10% of public Tweets.
         * @summary Sample 10% stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweetsSample10Stream: async (partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'partition' is not null or undefined
            assertParamExists('getTweetsSample10Stream', 'partition', partition)
            const localVarPath = `/2/tweets/sample10/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (backfillMinutes !== undefined) {
                localVarQueryParameter['backfill_minutes'] = backfillMinutes;
            }

            if (partition !== undefined) {
                localVarQueryParameter['partition'] = partition;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Hides or unhides a reply to an owned conversation.
         * @summary Hide replies
         * @param {string} tweetId The ID of the reply that you want to hide or unhide.
         * @param {TweetHideRequest} [tweetHideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideReplyById: async (tweetId: string, tweetHideRequest?: TweetHideRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tweetId' is not null or undefined
            assertParamExists('hideReplyById', 'tweetId', tweetId)
            const localVarPath = `/2/tweets/{tweet_id}/hidden`
                .replace(`{${"tweet_id"}}`, encodeURIComponent(String(tweetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.moderate.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tweetHideRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Tweets associated with the provided List ID.
         * @summary List Tweets timeline by List ID.
         * @param {string} id The ID of the List.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listsIdTweets: async (id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listsIdTweets', 'id', id)
            const localVarPath = `/2/lists/{id}/tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams a deterministic 1% of public Tweets.
         * @summary Sample stream
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sampleStream: async (backfillMinutes?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/tweets/sample/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (backfillMinutes !== undefined) {
                localVarQueryParameter['backfill_minutes'] = backfillMinutes;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Streams Tweets matching the stream\'s active rule set.
         * @summary Filtered stream
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchStream: async (backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/tweets/search/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (backfillMinutes !== undefined) {
                localVarQueryParameter['backfill_minutes'] = backfillMinutes;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the list of Users who purchased a ticket to the given space
         * @summary Retrieve the list of Users who purchased a ticket to the given space
         * @param {string} id The ID of the Space to be retrieved.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spaceBuyers: async (id: string, paginationToken?: string, maxResults?: number, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('spaceBuyers', 'id', id)
            const localVarPath = `/2/spaces/{id}/buyers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves Tweets shared in the specified Space.
         * @summary Retrieve Tweets from a Space.
         * @param {string} id The ID of the Space to be retrieved.
         * @param {number} [maxResults] The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spaceTweets: async (id: string, maxResults?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('spaceTweets', 'id', id)
            const localVarPath = `/2/spaces/{id}/tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["space.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweet Counts that match a search query.
         * @summary Full archive search counts
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'minute' | 'hour' | 'day'} [granularity] The granularity for the search counts results.
         * @param {Set<'end' | 'start' | 'tweet_count'>} [searchCountFields] A comma separated list of SearchCount fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetCountsFullArchiveSearch: async (query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, paginationToken?: string, granularity?: 'minute' | 'hour' | 'day', searchCountFields?: Set<'end' | 'start' | 'tweet_count'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('tweetCountsFullArchiveSearch', 'query', query)
            const localVarPath = `/2/tweets/counts/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (searchCountFields) {
                localVarQueryParameter['search_count.fields'] = Array.from(searchCountFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweet Counts from the last 7 days that match a search query.
         * @summary Recent search counts
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'minute' | 'hour' | 'day'} [granularity] The granularity for the search counts results.
         * @param {Set<'end' | 'start' | 'tweet_count'>} [searchCountFields] A comma separated list of SearchCount fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetCountsRecentSearch: async (query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, paginationToken?: string, granularity?: 'minute' | 'hour' | 'day', searchCountFields?: Set<'end' | 'start' | 'tweet_count'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('tweetCountsRecentSearch', 'query', query)
            const localVarPath = `/2/tweets/counts/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (searchCountFields) {
                localVarQueryParameter['search_count.fields'] = Array.from(searchCountFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweets that match a search query.
         * @summary Full-archive search
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'recency' | 'relevancy'} [sortOrder] This order in which to return results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsFullarchiveSearch: async (query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, paginationToken?: string, sortOrder?: 'recency' | 'relevancy', tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('tweetsFullarchiveSearch', 'query', query)
            const localVarPath = `/2/tweets/search/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweets from the last 7 days that match a search query.
         * @summary Recent search
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'recency' | 'relevancy'} [sortOrder] This order in which to return results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsRecentSearch: async (query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, paginationToken?: string, sortOrder?: 'recency' | 'relevancy', tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('tweetsRecentSearch', 'query', query)
            const localVarPath = `/2/tweets/search/recent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (nextToken !== undefined) {
                localVarQueryParameter['next_token'] = nextToken;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.
         * @summary Causes the User (in the path) to like the specified Tweet
         * @param {string} id The ID of the authenticated source User that is requesting to like the Tweet.
         * @param {UsersLikesCreateRequest} [usersLikesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdLike: async (id: string, usersLikesCreateRequest?: UsersLikesCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdLike', 'id', id)
            const localVarPath = `/2/users/{id}/likes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["like.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersLikesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Tweets liked by the provided User ID
         * @summary Returns Tweet objects liked by the provided User ID
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdLikedTweets: async (id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdLikedTweets', 'id', id)
            const localVarPath = `/2/users/{id}/liked_tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["like.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweet objects that mention username associated to the provided User ID
         * @summary User mention timeline by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMentions: async (id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdMentions', 'id', id)
            const localVarPath = `/2/users/{id}/mentions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.
         * @summary Causes the User (in the path) to retweet the specified Tweet.
         * @param {string} id The ID of the authenticated source User that is requesting to retweet the Tweet.
         * @param {UsersRetweetsCreateRequest} [usersRetweetsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdRetweets: async (id: string, usersRetweetsCreateRequest?: UsersRetweetsCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdRetweets', 'id', id)
            const localVarPath = `/2/users/{id}/retweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "tweet.write", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersRetweetsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns Tweet objects that appears in the provided User ID\'s home timeline
         * @summary User home timeline by User ID
         * @param {string} id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdTimeline: async (id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdTimeline', 'id', id)
            const localVarPath = `/2/users/{id}/timelines/reverse_chronological`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)

            // authentication UserToken required

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (exclude) {
                localVarQueryParameter['exclude'] = Array.from(exclude).join(COLLECTION_FORMATS.csv);
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Tweets authored by the provided User ID
         * @summary User Tweets timeline by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdTweets: async (id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdTweets', 'id', id)
            const localVarPath = `/2/users/{id}/tweets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (sinceId !== undefined) {
                localVarQueryParameter['since_id'] = sinceId;
            }

            if (untilId !== undefined) {
                localVarQueryParameter['until_id'] = untilId;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (exclude) {
                localVarQueryParameter['exclude'] = Array.from(exclude).join(COLLECTION_FORMATS.csv);
            }

            if (startTime !== undefined) {
                localVarQueryParameter['start_time'] = (startTime as any instanceof Date) ?
                    (startTime as any).toISOString() :
                    startTime;
            }

            if (endTime !== undefined) {
                localVarQueryParameter['end_time'] = (endTime as any instanceof Date) ?
                    (endTime as any).toISOString() :
                    endTime;
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (mediaFields) {
                localVarQueryParameter['media.fields'] = Array.from(mediaFields).join(COLLECTION_FORMATS.csv);
            }

            if (pollFields) {
                localVarQueryParameter['poll.fields'] = Array.from(pollFields).join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (placeFields) {
                localVarQueryParameter['place.fields'] = Array.from(placeFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request
         * @summary Causes the User (in the path) to unlike the specified Tweet
         * @param {string} id The ID of the authenticated source User that is requesting to unlike the Tweet.
         * @param {string} tweetId The ID of the Tweet that the User is requesting to unlike.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnlike: async (id: string, tweetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdUnlike', 'id', id)
            // verify required parameter 'tweetId' is not null or undefined
            assertParamExists('usersIdUnlike', 'tweetId', tweetId)
            const localVarPath = `/2/users/{id}/likes/{tweet_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"tweet_id"}}`, encodeURIComponent(String(tweetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["like.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request
         * @summary Causes the User (in the path) to unretweet the specified Tweet
         * @param {string} id The ID of the authenticated source User that is requesting to retweet the Tweet.
         * @param {string} sourceTweetId The ID of the Tweet that the User is requesting to unretweet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnretweets: async (id: string, sourceTweetId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdUnretweets', 'id', id)
            // verify required parameter 'sourceTweetId' is not null or undefined
            assertParamExists('usersIdUnretweets', 'sourceTweetId', sourceTweetId)
            const localVarPath = `/2/users/{id}/retweets/{source_tweet_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"source_tweet_id"}}`, encodeURIComponent(String(sourceTweetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "tweet.write", "users.read"], configuration)

            // authentication UserToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TweetsApi - functional programming interface
 * @export
 */
export const TweetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TweetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add or delete rules from a User\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
         * @summary Add/Delete rules
         * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest 
         * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addOrDeleteRules(addOrDeleteRulesRequest: AddOrDeleteRulesRequest, dryRun?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddOrDeleteRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addOrDeleteRules(addOrDeleteRulesRequest, dryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User to create a Tweet under the authorized account.
         * @summary Creation of a Tweet
         * @param {TweetCreateRequest} tweetCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTweet(tweetCreateRequest: TweetCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TweetCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTweet(tweetCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete specified Tweet (in the path) by ID.
         * @summary Tweet delete by Tweet ID
         * @param {string} id The ID of the Tweet to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTweetById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TweetDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTweetById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID.
         * @summary Tweet lookup by Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTweetById(id: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTweetById(id, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID.
         * @summary Tweet lookup by Tweet IDs
         * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTweetsById(ids: Array<string>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTweetsById(ids, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.
         * @summary Retrieve Tweets that quote a Tweet.
         * @param {string} id A single Tweet ID.
         * @param {number} [maxResults] The maximum number of results to be returned.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTweetsThatQuoteATweet(id: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsIdQuoteTweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTweetsThatQuoteATweet(id, maxResults, paginationToken, exclude, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns rules from a User\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
         * @summary Rules lookup
         * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; returned in a request to paginate through results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRules(ids?: Array<string>, maxResults?: number, paginationToken?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RulesLookupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRules(ids, maxResults, paginationToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Streams 100% of public Tweets.
         * @summary Firehose stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTweetsFirehoseStream(partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamingTweetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTweetsFirehoseStream(partition, backfillMinutes, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Streams a deterministic 10% of public Tweets.
         * @summary Sample 10% stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTweetsSample10Stream(partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsSample10StreamResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTweetsSample10Stream(partition, backfillMinutes, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Hides or unhides a reply to an owned conversation.
         * @summary Hide replies
         * @param {string} tweetId The ID of the reply that you want to hide or unhide.
         * @param {TweetHideRequest} [tweetHideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hideReplyById(tweetId: string, tweetHideRequest?: TweetHideRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TweetHideResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hideReplyById(tweetId, tweetHideRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Tweets associated with the provided List ID.
         * @summary List Tweets timeline by List ID.
         * @param {string} id The ID of the List.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listsIdTweets(id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2ListsIdTweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listsIdTweets(id, maxResults, paginationToken, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Streams a deterministic 1% of public Tweets.
         * @summary Sample stream
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sampleStream(backfillMinutes?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamingTweetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sampleStream(backfillMinutes, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Streams Tweets matching the stream\'s active rule set.
         * @summary Filtered stream
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchStream(backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FilteredStreamingTweetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchStream(backfillMinutes, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the list of Users who purchased a ticket to the given space
         * @summary Retrieve the list of Users who purchased a ticket to the given space
         * @param {string} id The ID of the Space to be retrieved.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spaceBuyers(id: string, paginationToken?: string, maxResults?: number, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesIdBuyersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spaceBuyers(id, paginationToken, maxResults, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves Tweets shared in the specified Space.
         * @summary Retrieve Tweets from a Space.
         * @param {string} id The ID of the Space to be retrieved.
         * @param {number} [maxResults] The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async spaceTweets(id: string, maxResults?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2SpacesIdTweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.spaceTweets(id, maxResults, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweet Counts that match a search query.
         * @summary Full archive search counts
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'minute' | 'hour' | 'day'} [granularity] The granularity for the search counts results.
         * @param {Set<'end' | 'start' | 'tweet_count'>} [searchCountFields] A comma separated list of SearchCount fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tweetCountsFullArchiveSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, paginationToken?: string, granularity?: 'minute' | 'hour' | 'day', searchCountFields?: Set<'end' | 'start' | 'tweet_count'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsCountsAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tweetCountsFullArchiveSearch(query, startTime, endTime, sinceId, untilId, nextToken, paginationToken, granularity, searchCountFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweet Counts from the last 7 days that match a search query.
         * @summary Recent search counts
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'minute' | 'hour' | 'day'} [granularity] The granularity for the search counts results.
         * @param {Set<'end' | 'start' | 'tweet_count'>} [searchCountFields] A comma separated list of SearchCount fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tweetCountsRecentSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, paginationToken?: string, granularity?: 'minute' | 'hour' | 'day', searchCountFields?: Set<'end' | 'start' | 'tweet_count'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsCountsRecentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tweetCountsRecentSearch(query, startTime, endTime, sinceId, untilId, nextToken, paginationToken, granularity, searchCountFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweets that match a search query.
         * @summary Full-archive search
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'recency' | 'relevancy'} [sortOrder] This order in which to return results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tweetsFullarchiveSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, paginationToken?: string, sortOrder?: 'recency' | 'relevancy', tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsSearchAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tweetsFullarchiveSearch(query, startTime, endTime, sinceId, untilId, maxResults, nextToken, paginationToken, sortOrder, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweets from the last 7 days that match a search query.
         * @summary Recent search
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'recency' | 'relevancy'} [sortOrder] This order in which to return results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tweetsRecentSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, paginationToken?: string, sortOrder?: 'recency' | 'relevancy', tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsSearchRecentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tweetsRecentSearch(query, startTime, endTime, sinceId, untilId, maxResults, nextToken, paginationToken, sortOrder, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.
         * @summary Causes the User (in the path) to like the specified Tweet
         * @param {string} id The ID of the authenticated source User that is requesting to like the Tweet.
         * @param {UsersLikesCreateRequest} [usersLikesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdLike(id: string, usersLikesCreateRequest?: UsersLikesCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersLikesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdLike(id, usersLikesCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Tweets liked by the provided User ID
         * @summary Returns Tweet objects liked by the provided User ID
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdLikedTweets(id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdLikedTweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdLikedTweets(id, maxResults, paginationToken, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweet objects that mention username associated to the provided User ID
         * @summary User mention timeline by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdMentions(id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdMentionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdMentions(id, sinceId, untilId, maxResults, paginationToken, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.
         * @summary Causes the User (in the path) to retweet the specified Tweet.
         * @param {string} id The ID of the authenticated source User that is requesting to retweet the Tweet.
         * @param {UsersRetweetsCreateRequest} [usersRetweetsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdRetweets(id: string, usersRetweetsCreateRequest?: UsersRetweetsCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersRetweetsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdRetweets(id, usersRetweetsCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns Tweet objects that appears in the provided User ID\'s home timeline
         * @summary User home timeline by User ID
         * @param {string} id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdTimeline(id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdTimelinesReverseChronologicalResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdTimeline(id, sinceId, untilId, maxResults, paginationToken, exclude, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Tweets authored by the provided User ID
         * @summary User Tweets timeline by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdTweets(id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdTweetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdTweets(id, sinceId, untilId, maxResults, paginationToken, exclude, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request
         * @summary Causes the User (in the path) to unlike the specified Tweet
         * @param {string} id The ID of the authenticated source User that is requesting to unlike the Tweet.
         * @param {string} tweetId The ID of the Tweet that the User is requesting to unlike.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdUnlike(id: string, tweetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersLikesDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdUnlike(id, tweetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request
         * @summary Causes the User (in the path) to unretweet the specified Tweet
         * @param {string} id The ID of the authenticated source User that is requesting to retweet the Tweet.
         * @param {string} sourceTweetId The ID of the Tweet that the User is requesting to unretweet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdUnretweets(id: string, sourceTweetId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersRetweetsDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdUnretweets(id, sourceTweetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TweetsApi - factory interface
 * @export
 */
export const TweetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TweetsApiFp(configuration)
    return {
        /**
         * Add or delete rules from a User\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
         * @summary Add/Delete rules
         * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest 
         * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrDeleteRules(addOrDeleteRulesRequest: AddOrDeleteRulesRequest, dryRun?: boolean, options?: any): AxiosPromise<AddOrDeleteRulesResponse> {
            return localVarFp.addOrDeleteRules(addOrDeleteRulesRequest, dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User to create a Tweet under the authorized account.
         * @summary Creation of a Tweet
         * @param {TweetCreateRequest} tweetCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTweet(tweetCreateRequest: TweetCreateRequest, options?: any): AxiosPromise<TweetCreateResponse> {
            return localVarFp.createTweet(tweetCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specified Tweet (in the path) by ID.
         * @summary Tweet delete by Tweet ID
         * @param {string} id The ID of the Tweet to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTweetById(id: string, options?: any): AxiosPromise<TweetDeleteResponse> {
            return localVarFp.deleteTweetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID.
         * @summary Tweet lookup by Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTweetById(id: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2TweetsIdResponse> {
            return localVarFp.findTweetById(id, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a variety of information about the Tweet specified by the requested ID.
         * @summary Tweet lookup by Tweet IDs
         * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTweetsById(ids: Array<string>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2TweetsResponse> {
            return localVarFp.findTweetsById(ids, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.
         * @summary Retrieve Tweets that quote a Tweet.
         * @param {string} id A single Tweet ID.
         * @param {number} [maxResults] The maximum number of results to be returned.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTweetsThatQuoteATweet(id: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2TweetsIdQuoteTweetsResponse> {
            return localVarFp.findTweetsThatQuoteATweet(id, maxResults, paginationToken, exclude, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns rules from a User\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
         * @summary Rules lookup
         * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; returned in a request to paginate through results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRules(ids?: Array<string>, maxResults?: number, paginationToken?: string, options?: any): AxiosPromise<RulesLookupResponse> {
            return localVarFp.getRules(ids, maxResults, paginationToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams 100% of public Tweets.
         * @summary Firehose stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweetsFirehoseStream(partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<StreamingTweetResponse> {
            return localVarFp.getTweetsFirehoseStream(partition, backfillMinutes, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams a deterministic 10% of public Tweets.
         * @summary Sample 10% stream
         * @param {number} partition The partition number.
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweetsSample10Stream(partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2TweetsSample10StreamResponse> {
            return localVarFp.getTweetsSample10Stream(partition, backfillMinutes, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Hides or unhides a reply to an owned conversation.
         * @summary Hide replies
         * @param {string} tweetId The ID of the reply that you want to hide or unhide.
         * @param {TweetHideRequest} [tweetHideRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hideReplyById(tweetId: string, tweetHideRequest?: TweetHideRequest, options?: any): AxiosPromise<TweetHideResponse> {
            return localVarFp.hideReplyById(tweetId, tweetHideRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Tweets associated with the provided List ID.
         * @summary List Tweets timeline by List ID.
         * @param {string} id The ID of the List.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listsIdTweets(id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2ListsIdTweetsResponse> {
            return localVarFp.listsIdTweets(id, maxResults, paginationToken, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams a deterministic 1% of public Tweets.
         * @summary Sample stream
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sampleStream(backfillMinutes?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<StreamingTweetResponse> {
            return localVarFp.sampleStream(backfillMinutes, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Streams Tweets matching the stream\'s active rule set.
         * @summary Filtered stream
         * @param {number} [backfillMinutes] The number of minutes of backfill requested.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchStream(backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<FilteredStreamingTweetResponse> {
            return localVarFp.searchStream(backfillMinutes, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the list of Users who purchased a ticket to the given space
         * @summary Retrieve the list of Users who purchased a ticket to the given space
         * @param {string} id The ID of the Space to be retrieved.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spaceBuyers(id: string, paginationToken?: string, maxResults?: number, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2SpacesIdBuyersResponse> {
            return localVarFp.spaceBuyers(id, paginationToken, maxResults, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves Tweets shared in the specified Space.
         * @summary Retrieve Tweets from a Space.
         * @param {string} id The ID of the Space to be retrieved.
         * @param {number} [maxResults] The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        spaceTweets(id: string, maxResults?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2SpacesIdTweetsResponse> {
            return localVarFp.spaceTweets(id, maxResults, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweet Counts that match a search query.
         * @summary Full archive search counts
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'minute' | 'hour' | 'day'} [granularity] The granularity for the search counts results.
         * @param {Set<'end' | 'start' | 'tweet_count'>} [searchCountFields] A comma separated list of SearchCount fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetCountsFullArchiveSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, paginationToken?: string, granularity?: 'minute' | 'hour' | 'day', searchCountFields?: Set<'end' | 'start' | 'tweet_count'>, options?: any): AxiosPromise<Get2TweetsCountsAllResponse> {
            return localVarFp.tweetCountsFullArchiveSearch(query, startTime, endTime, sinceId, untilId, nextToken, paginationToken, granularity, searchCountFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweet Counts from the last 7 days that match a search query.
         * @summary Recent search counts
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'minute' | 'hour' | 'day'} [granularity] The granularity for the search counts results.
         * @param {Set<'end' | 'start' | 'tweet_count'>} [searchCountFields] A comma separated list of SearchCount fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetCountsRecentSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, paginationToken?: string, granularity?: 'minute' | 'hour' | 'day', searchCountFields?: Set<'end' | 'start' | 'tweet_count'>, options?: any): AxiosPromise<Get2TweetsCountsRecentResponse> {
            return localVarFp.tweetCountsRecentSearch(query, startTime, endTime, sinceId, untilId, nextToken, paginationToken, granularity, searchCountFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweets that match a search query.
         * @summary Full-archive search
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'recency' | 'relevancy'} [sortOrder] This order in which to return results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsFullarchiveSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, paginationToken?: string, sortOrder?: 'recency' | 'relevancy', tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2TweetsSearchAllResponse> {
            return localVarFp.tweetsFullarchiveSearch(query, startTime, endTime, sinceId, untilId, maxResults, nextToken, paginationToken, sortOrder, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweets from the last 7 days that match a search query.
         * @summary Recent search
         * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
         * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
         * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
         * @param {number} [maxResults] The maximum number of search results to be returned by a request.
         * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
         * @param {'recency' | 'relevancy'} [sortOrder] This order in which to return results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsRecentSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, paginationToken?: string, sortOrder?: 'recency' | 'relevancy', tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2TweetsSearchRecentResponse> {
            return localVarFp.tweetsRecentSearch(query, startTime, endTime, sinceId, untilId, maxResults, nextToken, paginationToken, sortOrder, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.
         * @summary Causes the User (in the path) to like the specified Tweet
         * @param {string} id The ID of the authenticated source User that is requesting to like the Tweet.
         * @param {UsersLikesCreateRequest} [usersLikesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdLike(id: string, usersLikesCreateRequest?: UsersLikesCreateRequest, options?: any): AxiosPromise<UsersLikesCreateResponse> {
            return localVarFp.usersIdLike(id, usersLikesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Tweets liked by the provided User ID
         * @summary Returns Tweet objects liked by the provided User ID
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdLikedTweets(id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2UsersIdLikedTweetsResponse> {
            return localVarFp.usersIdLikedTweets(id, maxResults, paginationToken, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweet objects that mention username associated to the provided User ID
         * @summary User mention timeline by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMentions(id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2UsersIdMentionsResponse> {
            return localVarFp.usersIdMentions(id, sinceId, untilId, maxResults, paginationToken, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.
         * @summary Causes the User (in the path) to retweet the specified Tweet.
         * @param {string} id The ID of the authenticated source User that is requesting to retweet the Tweet.
         * @param {UsersRetweetsCreateRequest} [usersRetweetsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdRetweets(id: string, usersRetweetsCreateRequest?: UsersRetweetsCreateRequest, options?: any): AxiosPromise<UsersRetweetsCreateResponse> {
            return localVarFp.usersIdRetweets(id, usersRetweetsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns Tweet objects that appears in the provided User ID\'s home timeline
         * @summary User home timeline by User ID
         * @param {string} id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdTimeline(id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2UsersIdTimelinesReverseChronologicalResponse> {
            return localVarFp.usersIdTimeline(id, sinceId, untilId, maxResults, paginationToken, exclude, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Tweets authored by the provided User ID
         * @summary User Tweets timeline by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
         * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
         * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
         * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
         * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdTweets(id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: any): AxiosPromise<Get2UsersIdTweetsResponse> {
            return localVarFp.usersIdTweets(id, sinceId, untilId, maxResults, paginationToken, exclude, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request
         * @summary Causes the User (in the path) to unlike the specified Tweet
         * @param {string} id The ID of the authenticated source User that is requesting to unlike the Tweet.
         * @param {string} tweetId The ID of the Tweet that the User is requesting to unlike.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnlike(id: string, tweetId: string, options?: any): AxiosPromise<UsersLikesDeleteResponse> {
            return localVarFp.usersIdUnlike(id, tweetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request
         * @summary Causes the User (in the path) to unretweet the specified Tweet
         * @param {string} id The ID of the authenticated source User that is requesting to retweet the Tweet.
         * @param {string} sourceTweetId The ID of the Tweet that the User is requesting to unretweet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnretweets(id: string, sourceTweetId: string, options?: any): AxiosPromise<UsersRetweetsDeleteResponse> {
            return localVarFp.usersIdUnretweets(id, sourceTweetId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TweetsApi - object-oriented interface
 * @export
 * @class TweetsApi
 * @extends {BaseAPI}
 */
export class TweetsApi extends BaseAPI {
    /**
     * Add or delete rules from a User\'s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
     * @summary Add/Delete rules
     * @param {AddOrDeleteRulesRequest} addOrDeleteRulesRequest 
     * @param {boolean} [dryRun] Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public addOrDeleteRules(addOrDeleteRulesRequest: AddOrDeleteRulesRequest, dryRun?: boolean, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).addOrDeleteRules(addOrDeleteRulesRequest, dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User to create a Tweet under the authorized account.
     * @summary Creation of a Tweet
     * @param {TweetCreateRequest} tweetCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public createTweet(tweetCreateRequest: TweetCreateRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).createTweet(tweetCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete specified Tweet (in the path) by ID.
     * @summary Tweet delete by Tweet ID
     * @param {string} id The ID of the Tweet to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public deleteTweetById(id: string, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).deleteTweetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a variety of information about the Tweet specified by the requested ID.
     * @summary Tweet lookup by Tweet ID
     * @param {string} id A single Tweet ID.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public findTweetById(id: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).findTweetById(id, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a variety of information about the Tweet specified by the requested ID.
     * @summary Tweet lookup by Tweet IDs
     * @param {Array<string>} ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public findTweetsById(ids: Array<string>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).findTweetsById(ids, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a variety of information about each Tweet that quotes the Tweet specified by the requested ID.
     * @summary Retrieve Tweets that quote a Tweet.
     * @param {string} id A single Tweet ID.
     * @param {number} [maxResults] The maximum number of results to be returned.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public findTweetsThatQuoteATweet(id: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).findTweetsThatQuoteATweet(id, maxResults, paginationToken, exclude, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns rules from a User\'s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
     * @summary Rules lookup
     * @param {Array<string>} [ids] A comma-separated list of Rule IDs.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This value is populated by passing the \&#39;next_token\&#39; returned in a request to paginate through results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public getRules(ids?: Array<string>, maxResults?: number, paginationToken?: string, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getRules(ids, maxResults, paginationToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams 100% of public Tweets.
     * @summary Firehose stream
     * @param {number} partition The partition number.
     * @param {number} [backfillMinutes] The number of minutes of backfill requested.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public getTweetsFirehoseStream(partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getTweetsFirehoseStream(partition, backfillMinutes, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams a deterministic 10% of public Tweets.
     * @summary Sample 10% stream
     * @param {number} partition The partition number.
     * @param {number} [backfillMinutes] The number of minutes of backfill requested.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp to which the Tweets will be provided.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public getTweetsSample10Stream(partition: number, backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).getTweetsSample10Stream(partition, backfillMinutes, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Hides or unhides a reply to an owned conversation.
     * @summary Hide replies
     * @param {string} tweetId The ID of the reply that you want to hide or unhide.
     * @param {TweetHideRequest} [tweetHideRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public hideReplyById(tweetId: string, tweetHideRequest?: TweetHideRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).hideReplyById(tweetId, tweetHideRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Tweets associated with the provided List ID.
     * @summary List Tweets timeline by List ID.
     * @param {string} id The ID of the List.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public listsIdTweets(id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).listsIdTweets(id, maxResults, paginationToken, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams a deterministic 1% of public Tweets.
     * @summary Sample stream
     * @param {number} [backfillMinutes] The number of minutes of backfill requested.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public sampleStream(backfillMinutes?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).sampleStream(backfillMinutes, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Streams Tweets matching the stream\'s active rule set.
     * @summary Filtered stream
     * @param {number} [backfillMinutes] The number of minutes of backfill requested.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public searchStream(backfillMinutes?: number, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).searchStream(backfillMinutes, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the list of Users who purchased a ticket to the given space
     * @summary Retrieve the list of Users who purchased a ticket to the given space
     * @param {string} id The ID of the Space to be retrieved.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {number} [maxResults] The maximum number of results.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public spaceBuyers(id: string, paginationToken?: string, maxResults?: number, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).spaceBuyers(id, paginationToken, maxResults, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves Tweets shared in the specified Space.
     * @summary Retrieve Tweets from a Space.
     * @param {string} id The ID of the Space to be retrieved.
     * @param {number} [maxResults] The number of Tweets to fetch from the provided space. If not provided, the value will default to the maximum of 100.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public spaceTweets(id: string, maxResults?: number, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).spaceTweets(id, maxResults, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweet Counts that match a search query.
     * @summary Full archive search counts
     * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {'minute' | 'hour' | 'day'} [granularity] The granularity for the search counts results.
     * @param {Set<'end' | 'start' | 'tweet_count'>} [searchCountFields] A comma separated list of SearchCount fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public tweetCountsFullArchiveSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, paginationToken?: string, granularity?: 'minute' | 'hour' | 'day', searchCountFields?: Set<'end' | 'start' | 'tweet_count'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).tweetCountsFullArchiveSearch(query, startTime, endTime, sinceId, untilId, nextToken, paginationToken, granularity, searchCountFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweet Counts from the last 7 days that match a search query.
     * @summary Recent search counts
     * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {'minute' | 'hour' | 'day'} [granularity] The granularity for the search counts results.
     * @param {Set<'end' | 'start' | 'tweet_count'>} [searchCountFields] A comma separated list of SearchCount fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public tweetCountsRecentSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, nextToken?: string, paginationToken?: string, granularity?: 'minute' | 'hour' | 'day', searchCountFields?: Set<'end' | 'start' | 'tweet_count'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).tweetCountsRecentSearch(query, startTime, endTime, sinceId, untilId, nextToken, paginationToken, granularity, searchCountFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweets that match a search query.
     * @summary Full-archive search
     * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {'recency' | 'relevancy'} [sortOrder] This order in which to return results.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public tweetsFullarchiveSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, paginationToken?: string, sortOrder?: 'recency' | 'relevancy', tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).tweetsFullarchiveSearch(query, startTime, endTime, sinceId, untilId, maxResults, nextToken, paginationToken, sortOrder, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweets from the last 7 days that match a search query.
     * @summary Recent search
     * @param {string} query One query/rule/filter for matching Tweets. Refer to https://t.co/rulelength to identify the max query length.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
     * @param {string} [sinceId] Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
     * @param {string} [untilId] Returns results with a Tweet ID less than (that is, older than) the specified ID.
     * @param {number} [maxResults] The maximum number of search results to be returned by a request.
     * @param {string} [nextToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
     * @param {'recency' | 'relevancy'} [sortOrder] This order in which to return results.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public tweetsRecentSearch(query: string, startTime?: string, endTime?: string, sinceId?: string, untilId?: string, maxResults?: number, nextToken?: string, paginationToken?: string, sortOrder?: 'recency' | 'relevancy', tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).tweetsRecentSearch(query, startTime, endTime, sinceId, untilId, maxResults, nextToken, paginationToken, sortOrder, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User (in the path) to like the specified Tweet. The User in the path must match the User context authorizing the request.
     * @summary Causes the User (in the path) to like the specified Tweet
     * @param {string} id The ID of the authenticated source User that is requesting to like the Tweet.
     * @param {UsersLikesCreateRequest} [usersLikesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdLike(id: string, usersLikesCreateRequest?: UsersLikesCreateRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).usersIdLike(id, usersLikesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Tweets liked by the provided User ID
     * @summary Returns Tweet objects liked by the provided User ID
     * @param {string} id The ID of the User to lookup.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdLikedTweets(id: string, maxResults?: number, paginationToken?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).usersIdLikedTweets(id, maxResults, paginationToken, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweet objects that mention username associated to the provided User ID
     * @summary User mention timeline by User ID
     * @param {string} id The ID of the User to lookup.
     * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
     * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdMentions(id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).usersIdMentions(id, sinceId, untilId, maxResults, paginationToken, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User (in the path) to retweet the specified Tweet. The User in the path must match the User context authorizing the request.
     * @summary Causes the User (in the path) to retweet the specified Tweet.
     * @param {string} id The ID of the authenticated source User that is requesting to retweet the Tweet.
     * @param {UsersRetweetsCreateRequest} [usersRetweetsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdRetweets(id: string, usersRetweetsCreateRequest?: UsersRetweetsCreateRequest, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).usersIdRetweets(id, usersRetweetsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns Tweet objects that appears in the provided User ID\'s home timeline
     * @summary User home timeline by User ID
     * @param {string} id The ID of the authenticated source User to list Reverse Chronological Timeline Tweets of.
     * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
     * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdTimeline(id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).usersIdTimeline(id, sinceId, untilId, maxResults, paginationToken, exclude, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Tweets authored by the provided User ID
     * @summary User Tweets timeline by User ID
     * @param {string} id The ID of the User to lookup.
     * @param {string} [sinceId] The minimum Tweet ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
     * @param {string} [untilId] The maximum Tweet ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {Set<'replies' | 'retweets'>} [exclude] The set of entities to exclude (e.g. \&#39;replies\&#39; or \&#39;retweets\&#39;).
     * @param {string} [startTime] YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Tweets will be provided. The since_id parameter takes precedence if it is also specified.
     * @param {string} [endTime] YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Tweets will be provided. The until_id parameter takes precedence if it is also specified.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>} [mediaFields] A comma separated list of Media fields to display.
     * @param {Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>} [pollFields] A comma separated list of Poll fields to display.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>} [placeFields] A comma separated list of Place fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdTweets(id: string, sinceId?: string, untilId?: string, maxResults?: number, paginationToken?: string, exclude?: Set<'replies' | 'retweets'>, startTime?: string, endTime?: string, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, expansions?: Set<'attachments.media_keys' | 'attachments.poll_ids' | 'author_id' | 'edit_history_tweet_ids' | 'entities.mentions.username' | 'geo.place_id' | 'in_reply_to_user_id' | 'referenced_tweets.id' | 'referenced_tweets.id.author_id'>, mediaFields?: Set<'alt_text' | 'duration_ms' | 'height' | 'media_key' | 'non_public_metrics' | 'organic_metrics' | 'preview_image_url' | 'promoted_metrics' | 'public_metrics' | 'type' | 'url' | 'variants' | 'width'>, pollFields?: Set<'duration_minutes' | 'end_datetime' | 'id' | 'options' | 'voting_status'>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, placeFields?: Set<'contained_within' | 'country' | 'country_code' | 'full_name' | 'geo' | 'id' | 'name' | 'place_type'>, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).usersIdTweets(id, sinceId, untilId, maxResults, paginationToken, exclude, startTime, endTime, tweetFields, expansions, mediaFields, pollFields, userFields, placeFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User (in the path) to unlike the specified Tweet. The User must match the User context authorizing the request
     * @summary Causes the User (in the path) to unlike the specified Tweet
     * @param {string} id The ID of the authenticated source User that is requesting to unlike the Tweet.
     * @param {string} tweetId The ID of the Tweet that the User is requesting to unlike.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdUnlike(id: string, tweetId: string, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).usersIdUnlike(id, tweetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User (in the path) to unretweet the specified Tweet. The User must match the User context authorizing the request
     * @summary Causes the User (in the path) to unretweet the specified Tweet
     * @param {string} id The ID of the authenticated source User that is requesting to retweet the Tweet.
     * @param {string} sourceTweetId The ID of the Tweet that the User is requesting to unretweet.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweetsApi
     */
    public usersIdUnretweets(id: string, sourceTweetId: string, options?: AxiosRequestConfig) {
        return TweetsApiFp(this.configuration).usersIdUnretweets(id, sourceTweetId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns information about the requesting User.
         * @summary User lookup me
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMyUser: async (userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/2/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)

            // authentication UserToken required

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about a User. Specify User by ID.
         * @summary User lookup by ID
         * @param {string} id The ID of the User to lookup.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserById: async (id: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findUserById', 'id', id)
            const localVarPath = `/2/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about a User. Specify User by username.
         * @summary User lookup by username
         * @param {string} username A username.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserByUsername: async (username: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('findUserByUsername', 'username', username)
            const localVarPath = `/2/users/by/username/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about Users. Specify Users by their ID.
         * @summary User lookup by IDs
         * @param {Array<string>} ids A list of User IDs, comma-separated. You can specify up to 100 IDs.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersById: async (ids: Array<string>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ids' is not null or undefined
            assertParamExists('findUsersById', 'ids', ids)
            const localVarPath = `/2/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (ids) {
                localVarQueryParameter['ids'] = ids.join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns information about Users. Specify Users by their username.
         * @summary User lookup by usernames
         * @param {Array<string>} usernames A list of usernames, comma-separated.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersByUsername: async (usernames: Array<string>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'usernames' is not null or undefined
            assertParamExists('findUsersByUsername', 'usernames', usernames)
            const localVarPath = `/2/users/by`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (usernames) {
                localVarQueryParameter['usernames'] = usernames.join(COLLECTION_FORMATS.csv);
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that follow a List by the provided List ID
         * @summary Returns User objects that follow a List by the provided List ID
         * @param {string} id The ID of the List.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGetFollowers: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listGetFollowers', 'id', id)
            const localVarPath = `/2/lists/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that are members of a List by the provided List ID.
         * @summary Returns User objects that are members of a List by the provided List ID.
         * @param {string} id The ID of the List.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGetMembers: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('listGetMembers', 'id', id)
            const localVarPath = `/2/lists/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["list.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that have liked the provided Tweet ID
         * @summary Returns User objects that have liked the provided Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsIdLikingUsers: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tweetsIdLikingUsers', 'id', id)
            const localVarPath = `/2/tweets/{id}/liking_users`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["like.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that have retweeted the provided Tweet ID
         * @summary Returns User objects that have retweeted the provided Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsIdRetweetingUsers: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tweetsIdRetweetingUsers', 'id', id)
            const localVarPath = `/2/tweets/{id}/retweeted_by`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request
         * @summary Block User by User ID
         * @param {string} id The ID of the authenticated source User that is requesting to block the target User.
         * @param {BlockUserRequest} blockUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBlock: async (id: string, blockUserRequest: BlockUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdBlock', 'id', id)
            // verify required parameter 'blockUserRequest' is not null or undefined
            assertParamExists('usersIdBlock', 'blockUserRequest', blockUserRequest)
            const localVarPath = `/2/users/{id}/blocking`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["block.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that are blocked by the provided User ID
         * @summary Returns User objects that are blocked by provided User ID
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBlocking: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdBlocking', 'id', id)
            const localVarPath = `/2/users/{id}/blocking`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["block.read", "tweet.read", "users.read"], configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request
         * @summary Follow User
         * @param {string} id The ID of the authenticated source User that is requesting to follow the target User.
         * @param {UsersFollowingCreateRequest} [usersFollowingCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFollow: async (id: string, usersFollowingCreateRequest?: UsersFollowingCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdFollow', 'id', id)
            const localVarPath = `/2/users/{id}/following`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["follows.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersFollowingCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users who are followers of the specified User ID.
         * @summary Followers by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFollowers: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdFollowers', 'id', id)
            const localVarPath = `/2/users/{id}/followers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["follows.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that are being followed by the provided User ID
         * @summary Following by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFollowing: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdFollowing', 'id', id)
            const localVarPath = `/2/users/{id}/following`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["follows.read", "tweet.read", "users.read"], configuration)

            // authentication BearerToken required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.
         * @summary Mute User by User ID.
         * @param {string} id The ID of the authenticated source User that is requesting to mute the target User.
         * @param {MuteUserRequest} [muteUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMute: async (id: string, muteUserRequest?: MuteUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdMute', 'id', id)
            const localVarPath = `/2/users/{id}/muting`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["mute.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(muteUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of Users that are muted by the provided User ID
         * @summary Returns User objects that are muted by the provided User ID
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMuting: async (id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersIdMuting', 'id', id)
            const localVarPath = `/2/users/{id}/muting`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["mute.read", "tweet.read", "users.read"], configuration)

            // authentication UserToken required

            if (maxResults !== undefined) {
                localVarQueryParameter['max_results'] = maxResults;
            }

            if (paginationToken !== undefined) {
                localVarQueryParameter['pagination_token'] = paginationToken;
            }

            if (userFields) {
                localVarQueryParameter['user.fields'] = Array.from(userFields).join(COLLECTION_FORMATS.csv);
            }

            if (expansions) {
                localVarQueryParameter['expansions'] = Array.from(expansions).join(COLLECTION_FORMATS.csv);
            }

            if (tweetFields) {
                localVarQueryParameter['tweet.fields'] = Array.from(tweetFields).join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the source User to unblock the target User. The source User must match the User context authorizing the request
         * @summary Unblock User by User ID
         * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unblock the target User.
         * @param {string} targetUserId The ID of the User that the source User is requesting to unblock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnblock: async (sourceUserId: string, targetUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUserId' is not null or undefined
            assertParamExists('usersIdUnblock', 'sourceUserId', sourceUserId)
            // verify required parameter 'targetUserId' is not null or undefined
            assertParamExists('usersIdUnblock', 'targetUserId', targetUserId)
            const localVarPath = `/2/users/{source_user_id}/blocking/{target_user_id}`
                .replace(`{${"source_user_id"}}`, encodeURIComponent(String(sourceUserId)))
                .replace(`{${"target_user_id"}}`, encodeURIComponent(String(targetUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["block.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the source User to unfollow the target User. The source User must match the User context authorizing the request
         * @summary Unfollow User
         * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unfollow the target User.
         * @param {string} targetUserId The ID of the User that the source User is requesting to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnfollow: async (sourceUserId: string, targetUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUserId' is not null or undefined
            assertParamExists('usersIdUnfollow', 'sourceUserId', sourceUserId)
            // verify required parameter 'targetUserId' is not null or undefined
            assertParamExists('usersIdUnfollow', 'targetUserId', targetUserId)
            const localVarPath = `/2/users/{source_user_id}/following/{target_user_id}`
                .replace(`{${"source_user_id"}}`, encodeURIComponent(String(sourceUserId)))
                .replace(`{${"target_user_id"}}`, encodeURIComponent(String(targetUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["follows.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Causes the source User to unmute the target User. The source User must match the User context authorizing the request
         * @summary Unmute User by User ID
         * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unmute the target User.
         * @param {string} targetUserId The ID of the User that the source User is requesting to unmute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnmute: async (sourceUserId: string, targetUserId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sourceUserId' is not null or undefined
            assertParamExists('usersIdUnmute', 'sourceUserId', sourceUserId)
            // verify required parameter 'targetUserId' is not null or undefined
            assertParamExists('usersIdUnmute', 'targetUserId', targetUserId)
            const localVarPath = `/2/users/{source_user_id}/muting/{target_user_id}`
                .replace(`{${"source_user_id"}}`, encodeURIComponent(String(sourceUserId)))
                .replace(`{${"target_user_id"}}`, encodeURIComponent(String(targetUserId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2UserToken required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2UserToken", ["mute.write", "tweet.read", "users.read"], configuration)

            // authentication UserToken required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * This endpoint returns information about the requesting User.
         * @summary User lookup me
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMyUser(userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersMeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMyUser(userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about a User. Specify User by ID.
         * @summary User lookup by ID
         * @param {string} id The ID of the User to lookup.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserById(id: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserById(id, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about a User. Specify User by username.
         * @summary User lookup by username
         * @param {string} username A username.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUserByUsername(username: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersByUsernameUsernameResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUserByUsername(username, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about Users. Specify Users by their ID.
         * @summary User lookup by IDs
         * @param {Array<string>} ids A list of User IDs, comma-separated. You can specify up to 100 IDs.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUsersById(ids: Array<string>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUsersById(ids, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint returns information about Users. Specify Users by their username.
         * @summary User lookup by usernames
         * @param {Array<string>} usernames A list of usernames, comma-separated.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUsersByUsername(usernames: Array<string>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersByResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUsersByUsername(usernames, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that follow a List by the provided List ID
         * @summary Returns User objects that follow a List by the provided List ID
         * @param {string} id The ID of the List.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGetFollowers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2ListsIdFollowersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGetFollowers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that are members of a List by the provided List ID.
         * @summary Returns User objects that are members of a List by the provided List ID.
         * @param {string} id The ID of the List.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGetMembers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2ListsIdMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGetMembers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that have liked the provided Tweet ID
         * @summary Returns User objects that have liked the provided Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tweetsIdLikingUsers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsIdLikingUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tweetsIdLikingUsers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that have retweeted the provided Tweet ID
         * @summary Returns User objects that have retweeted the provided Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tweetsIdRetweetingUsers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2TweetsIdRetweetedByResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tweetsIdRetweetingUsers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request
         * @summary Block User by User ID
         * @param {string} id The ID of the authenticated source User that is requesting to block the target User.
         * @param {BlockUserRequest} blockUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdBlock(id: string, blockUserRequest: BlockUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockUserMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdBlock(id, blockUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that are blocked by the provided User ID
         * @summary Returns User objects that are blocked by provided User ID
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdBlocking(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdBlockingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdBlocking(id, maxResults, paginationToken, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request
         * @summary Follow User
         * @param {string} id The ID of the authenticated source User that is requesting to follow the target User.
         * @param {UsersFollowingCreateRequest} [usersFollowingCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdFollow(id: string, usersFollowingCreateRequest?: UsersFollowingCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersFollowingCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdFollow(id, usersFollowingCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users who are followers of the specified User ID.
         * @summary Followers by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdFollowers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdFollowersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdFollowers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that are being followed by the provided User ID
         * @summary Following by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdFollowing(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdFollowingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdFollowing(id, maxResults, paginationToken, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.
         * @summary Mute User by User ID.
         * @param {string} id The ID of the authenticated source User that is requesting to mute the target User.
         * @param {MuteUserRequest} [muteUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdMute(id: string, muteUserRequest?: MuteUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MuteUserMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdMute(id, muteUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of Users that are muted by the provided User ID
         * @summary Returns User objects that are muted by the provided User ID
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdMuting(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Get2UsersIdMutingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdMuting(id, maxResults, paginationToken, userFields, expansions, tweetFields, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the source User to unblock the target User. The source User must match the User context authorizing the request
         * @summary Unblock User by User ID
         * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unblock the target User.
         * @param {string} targetUserId The ID of the User that the source User is requesting to unblock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdUnblock(sourceUserId: string, targetUserId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockUserMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdUnblock(sourceUserId, targetUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the source User to unfollow the target User. The source User must match the User context authorizing the request
         * @summary Unfollow User
         * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unfollow the target User.
         * @param {string} targetUserId The ID of the User that the source User is requesting to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdUnfollow(sourceUserId: string, targetUserId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersFollowingDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdUnfollow(sourceUserId, targetUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Causes the source User to unmute the target User. The source User must match the User context authorizing the request
         * @summary Unmute User by User ID
         * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unmute the target User.
         * @param {string} targetUserId The ID of the User that the source User is requesting to unmute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersIdUnmute(sourceUserId: string, targetUserId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MuteUserMutationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersIdUnmute(sourceUserId, targetUserId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * This endpoint returns information about the requesting User.
         * @summary User lookup me
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMyUser(userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2UsersMeResponse> {
            return localVarFp.findMyUser(userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about a User. Specify User by ID.
         * @summary User lookup by ID
         * @param {string} id The ID of the User to lookup.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserById(id: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2UsersIdResponse> {
            return localVarFp.findUserById(id, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about a User. Specify User by username.
         * @summary User lookup by username
         * @param {string} username A username.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUserByUsername(username: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2UsersByUsernameUsernameResponse> {
            return localVarFp.findUserByUsername(username, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about Users. Specify Users by their ID.
         * @summary User lookup by IDs
         * @param {Array<string>} ids A list of User IDs, comma-separated. You can specify up to 100 IDs.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersById(ids: Array<string>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2UsersResponse> {
            return localVarFp.findUsersById(ids, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns information about Users. Specify Users by their username.
         * @summary User lookup by usernames
         * @param {Array<string>} usernames A list of usernames, comma-separated.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUsersByUsername(usernames: Array<string>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2UsersByResponse> {
            return localVarFp.findUsersByUsername(usernames, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that follow a List by the provided List ID
         * @summary Returns User objects that follow a List by the provided List ID
         * @param {string} id The ID of the List.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGetFollowers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2ListsIdFollowersResponse> {
            return localVarFp.listGetFollowers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that are members of a List by the provided List ID.
         * @summary Returns User objects that are members of a List by the provided List ID.
         * @param {string} id The ID of the List.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGetMembers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2ListsIdMembersResponse> {
            return localVarFp.listGetMembers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that have liked the provided Tweet ID
         * @summary Returns User objects that have liked the provided Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsIdLikingUsers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2TweetsIdLikingUsersResponse> {
            return localVarFp.tweetsIdLikingUsers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that have retweeted the provided Tweet ID
         * @summary Returns User objects that have retweeted the provided Tweet ID
         * @param {string} id A single Tweet ID.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tweetsIdRetweetingUsers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2TweetsIdRetweetedByResponse> {
            return localVarFp.tweetsIdRetweetingUsers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request
         * @summary Block User by User ID
         * @param {string} id The ID of the authenticated source User that is requesting to block the target User.
         * @param {BlockUserRequest} blockUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBlock(id: string, blockUserRequest: BlockUserRequest, options?: any): AxiosPromise<BlockUserMutationResponse> {
            return localVarFp.usersIdBlock(id, blockUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that are blocked by the provided User ID
         * @summary Returns User objects that are blocked by provided User ID
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdBlocking(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2UsersIdBlockingResponse> {
            return localVarFp.usersIdBlocking(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request
         * @summary Follow User
         * @param {string} id The ID of the authenticated source User that is requesting to follow the target User.
         * @param {UsersFollowingCreateRequest} [usersFollowingCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFollow(id: string, usersFollowingCreateRequest?: UsersFollowingCreateRequest, options?: any): AxiosPromise<UsersFollowingCreateResponse> {
            return localVarFp.usersIdFollow(id, usersFollowingCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users who are followers of the specified User ID.
         * @summary Followers by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFollowers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2UsersIdFollowersResponse> {
            return localVarFp.usersIdFollowers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that are being followed by the provided User ID
         * @summary Following by User ID
         * @param {string} id The ID of the User to lookup.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdFollowing(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2UsersIdFollowingResponse> {
            return localVarFp.usersIdFollowing(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.
         * @summary Mute User by User ID.
         * @param {string} id The ID of the authenticated source User that is requesting to mute the target User.
         * @param {MuteUserRequest} [muteUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMute(id: string, muteUserRequest?: MuteUserRequest, options?: any): AxiosPromise<MuteUserMutationResponse> {
            return localVarFp.usersIdMute(id, muteUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of Users that are muted by the provided User ID
         * @summary Returns User objects that are muted by the provided User ID
         * @param {string} id The ID of the authenticated source User for whom to return results.
         * @param {number} [maxResults] The maximum number of results.
         * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
         * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
         * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
         * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdMuting(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: any): AxiosPromise<Get2UsersIdMutingResponse> {
            return localVarFp.usersIdMuting(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the source User to unblock the target User. The source User must match the User context authorizing the request
         * @summary Unblock User by User ID
         * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unblock the target User.
         * @param {string} targetUserId The ID of the User that the source User is requesting to unblock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnblock(sourceUserId: string, targetUserId: string, options?: any): AxiosPromise<BlockUserMutationResponse> {
            return localVarFp.usersIdUnblock(sourceUserId, targetUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the source User to unfollow the target User. The source User must match the User context authorizing the request
         * @summary Unfollow User
         * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unfollow the target User.
         * @param {string} targetUserId The ID of the User that the source User is requesting to unfollow.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnfollow(sourceUserId: string, targetUserId: string, options?: any): AxiosPromise<UsersFollowingDeleteResponse> {
            return localVarFp.usersIdUnfollow(sourceUserId, targetUserId, options).then((request) => request(axios, basePath));
        },
        /**
         * Causes the source User to unmute the target User. The source User must match the User context authorizing the request
         * @summary Unmute User by User ID
         * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unmute the target User.
         * @param {string} targetUserId The ID of the User that the source User is requesting to unmute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersIdUnmute(sourceUserId: string, targetUserId: string, options?: any): AxiosPromise<MuteUserMutationResponse> {
            return localVarFp.usersIdUnmute(sourceUserId, targetUserId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * This endpoint returns information about the requesting User.
     * @summary User lookup me
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findMyUser(userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).findMyUser(userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about a User. Specify User by ID.
     * @summary User lookup by ID
     * @param {string} id The ID of the User to lookup.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUserById(id: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).findUserById(id, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about a User. Specify User by username.
     * @summary User lookup by username
     * @param {string} username A username.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUserByUsername(username: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).findUserByUsername(username, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about Users. Specify Users by their ID.
     * @summary User lookup by IDs
     * @param {Array<string>} ids A list of User IDs, comma-separated. You can specify up to 100 IDs.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUsersById(ids: Array<string>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).findUsersById(ids, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns information about Users. Specify Users by their username.
     * @summary User lookup by usernames
     * @param {Array<string>} usernames A list of usernames, comma-separated.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public findUsersByUsername(usernames: Array<string>, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).findUsersByUsername(usernames, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that follow a List by the provided List ID
     * @summary Returns User objects that follow a List by the provided List ID
     * @param {string} id The ID of the List.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listGetFollowers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listGetFollowers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that are members of a List by the provided List ID.
     * @summary Returns User objects that are members of a List by the provided List ID.
     * @param {string} id The ID of the List.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listGetMembers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).listGetMembers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that have liked the provided Tweet ID
     * @summary Returns User objects that have liked the provided Tweet ID
     * @param {string} id A single Tweet ID.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tweetsIdLikingUsers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).tweetsIdLikingUsers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that have retweeted the provided Tweet ID
     * @summary Returns User objects that have retweeted the provided Tweet ID
     * @param {string} id A single Tweet ID.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public tweetsIdRetweetingUsers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).tweetsIdRetweetingUsers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User (in the path) to block the target User. The User (in the path) must match the User context authorizing the request
     * @summary Block User by User ID
     * @param {string} id The ID of the authenticated source User that is requesting to block the target User.
     * @param {BlockUserRequest} blockUserRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdBlock(id: string, blockUserRequest: BlockUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdBlock(id, blockUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that are blocked by the provided User ID
     * @summary Returns User objects that are blocked by provided User ID
     * @param {string} id The ID of the authenticated source User for whom to return results.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdBlocking(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdBlocking(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User(in the path) to follow, or “request to follow” for protected Users, the target User. The User(in the path) must match the User context authorizing the request
     * @summary Follow User
     * @param {string} id The ID of the authenticated source User that is requesting to follow the target User.
     * @param {UsersFollowingCreateRequest} [usersFollowingCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdFollow(id: string, usersFollowingCreateRequest?: UsersFollowingCreateRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdFollow(id, usersFollowingCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users who are followers of the specified User ID.
     * @summary Followers by User ID
     * @param {string} id The ID of the User to lookup.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdFollowers(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdFollowers(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that are being followed by the provided User ID
     * @summary Following by User ID
     * @param {string} id The ID of the User to lookup.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get a specified \&#39;page\&#39; of results.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdFollowing(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdFollowing(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the User (in the path) to mute the target User. The User (in the path) must match the User context authorizing the request.
     * @summary Mute User by User ID.
     * @param {string} id The ID of the authenticated source User that is requesting to mute the target User.
     * @param {MuteUserRequest} [muteUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdMute(id: string, muteUserRequest?: MuteUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdMute(id, muteUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of Users that are muted by the provided User ID
     * @summary Returns User objects that are muted by the provided User ID
     * @param {string} id The ID of the authenticated source User for whom to return results.
     * @param {number} [maxResults] The maximum number of results.
     * @param {string} [paginationToken] This parameter is used to get the next \&#39;page\&#39; of results.
     * @param {Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>} [userFields] A comma separated list of User fields to display.
     * @param {Set<'pinned_tweet_id'>} [expansions] A comma separated list of fields to expand.
     * @param {Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>} [tweetFields] A comma separated list of Tweet fields to display.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdMuting(id: string, maxResults?: number, paginationToken?: string, userFields?: Set<'created_at' | 'description' | 'entities' | 'id' | 'location' | 'name' | 'pinned_tweet_id' | 'profile_image_url' | 'protected' | 'public_metrics' | 'url' | 'username' | 'verified' | 'verified_type' | 'withheld'>, expansions?: Set<'pinned_tweet_id'>, tweetFields?: Set<'attachments' | 'author_id' | 'context_annotations' | 'conversation_id' | 'created_at' | 'edit_controls' | 'edit_history_tweet_ids' | 'entities' | 'geo' | 'id' | 'in_reply_to_user_id' | 'lang' | 'non_public_metrics' | 'organic_metrics' | 'possibly_sensitive' | 'promoted_metrics' | 'public_metrics' | 'referenced_tweets' | 'reply_settings' | 'source' | 'text' | 'withheld'>, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdMuting(id, maxResults, paginationToken, userFields, expansions, tweetFields, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the source User to unblock the target User. The source User must match the User context authorizing the request
     * @summary Unblock User by User ID
     * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unblock the target User.
     * @param {string} targetUserId The ID of the User that the source User is requesting to unblock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdUnblock(sourceUserId: string, targetUserId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdUnblock(sourceUserId, targetUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the source User to unfollow the target User. The source User must match the User context authorizing the request
     * @summary Unfollow User
     * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unfollow the target User.
     * @param {string} targetUserId The ID of the User that the source User is requesting to unfollow.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdUnfollow(sourceUserId: string, targetUserId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdUnfollow(sourceUserId, targetUserId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Causes the source User to unmute the target User. The source User must match the User context authorizing the request
     * @summary Unmute User by User ID
     * @param {string} sourceUserId The ID of the authenticated source User that is requesting to unmute the target User.
     * @param {string} targetUserId The ID of the User that the source User is requesting to unmute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersIdUnmute(sourceUserId: string, targetUserId: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersIdUnmute(sourceUserId, targetUserId, options).then((request) => request(this.axios, this.basePath));
    }
}


